;;; semantic-grammar.wy -- LALR grammar of Semantic input grammars
;;
;; Copyright (C) 2002, 2003 David Ponce
;;
;; Author: David Ponce <david@dponce.com>
;; Maintainer: David Ponce <david@dponce.com>
;; Created: 26 Aug 2002
;; Keywords: syntax
;; X-RCS: $Id: semantic-grammar.wy,v 1.8 2003-08-15 13:06:17 ponced Exp $
;;
;; This file is not part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;%package semantic-grammar-wy

%languagemode wy-mode

;; Main
%start grammar
;; Reparse
%start prologue epilogue declaration nonterminal rule
;; EXPANDFULL
%start put_names put_values

;; Keywords
%token LANGUAGEMODE    "%languagemode"
%token LEFT            "%left"
%token NONASSOC        "%nonassoc"
%token PACKAGE         "%package"
%token PREC            "%prec"
%token PUT             "%put"
%token QUOTEMODE       "%quotemode"
%token RIGHT           "%right"
%token SCOPESTART      "%scopestart"
%token START           "%start"
%token TOKEN           "%token"
%token USE-MACROS      "%use-macros"

;; Obsolete keywords
%token KEYWORDTABLE    "%keywordtable"
%token OUTPUTFILE      "%outputfile"
%token PARSETABLE      "%parsetable"
%token SETUPFUNCTION   "%setupfunction"
%token TOKENTABLE      "%tokentable"

;; Literals
%token <string>        STRING
%token <symbol>        SYMBOL
%token <symbol>        PERCENT_PERCENT "%%"
%token <char>          CHARACTER
%token <sexp>          SEXP
%token <sexp>          PREFIXED_LIST "\\s'\\s-*("
%token <code>          PROLOGUE "%{...%}"
%token <code>          EPILOGUE "%%...EOF"

;; Blocks
%token <semantic-list> PAREN_BLOCK "^("
%token <semantic-list> BRACE_BLOCK "^{"

;; Parens
%token <open-paren>    LBRACE      "{"
%token <close-paren>   RBRACE      "}"

;; Punctuations
%token <punctuation>   COLON       ":"
%token <punctuation>   SEMI        ";"
%token <punctuation>   OR          "|"
%token <punctuation>   LT          "<"
%token <punctuation>   GT          ">"

%%

grammar:
    prologue
  | epilogue
  | declaration
  | nonterminal
  | PERCENT_PERCENT
  ;

;;; Prologue/Epilogue
;;
prologue:
    PROLOGUE
    (CODE-TAG "prologue" nil)
  ;

epilogue:
    EPILOGUE
    (CODE-TAG "epilogue" nil)
  ;

;;; Declarations
;;
declaration:
    decl
    (eval $1)
  ;

decl:
    languagemode_decl
  | package_decl
  | precedence_decl
  | put_decl
  | quotemode_decl
  | scopestart_decl
  | start_decl
  | token_decl
  | use_macros_decl
 ;; Obsoletes declarations    
  | keywordtable_decl
  | outputfile_decl
  | parsetable_decl
  | setupfunction_decl
  | tokentable_decl
  ;

languagemode_decl:
    LANGUAGEMODE symbols
    `(TAG ',(car $2) 'languagemode :rest ',(cdr $2))
  ;

package_decl:
    PACKAGE SYMBOL
    `(PACKAGE-TAG ',$2 nil)
  ;

precedence_decl:
    associativity token_type_opt items
    `(TAG ',$1 'assoc :type ',$2 :value ',$3)
  ;

associativity:
    LEFT
    (progn "left")
  | RIGHT
    (progn "right")
  | NONASSOC
    (progn "nonassoc")
  ;

put_decl:
    PUT SYMBOL put_value
    `(TAG ',$2 'put :value ',(list $3))
  | PUT SYMBOL put_value_list
    (let* ((vals (mapcar 'semantic-tag-name $3)))
      `(TAG ',$2 'put :value ',vals))
  | PUT put_name_list put_value
    (let* ((names (mapcar 'semantic-tag-name $2)))
      `(TAG ',(car names) 'put :rest ',(cdr names) :value ',(list $3)))
  | PUT put_name_list put_value_list
    (let* ((names (mapcar 'semantic-tag-name $2))
           (vals  (mapcar 'semantic-tag-name $3)))
      `(TAG ',(car names) 'put :rest ',(cdr names) :value ',vals))
  ;

put_name_list:
    BRACE_BLOCK
    (EXPANDFULL $1 put_names)
  ;

put_names:
    LBRACE
    ()
  | RBRACE
    ()
  | SYMBOL
 ;; Must return a list of Semantic tags to EXPANDFULL!
    (TAG $1 'put-name)
  ;

put_value_list:
    BRACE_BLOCK
    (EXPANDFULL $1 put_values)
  ;

put_values:
    LBRACE
    ()
  | RBRACE
    ()
  | put_value
 ;; Must return a list of Semantic tags to EXPANDFULL!
    (TAG $1 'put-value)
  ;

put_value:
    SYMBOL any_value
    (cons $1 $2)
  ;

scopestart_decl:
    SCOPESTART SYMBOL
    `(TAG ',$2 'scopestart)
  ;

quotemode_decl:
    QUOTEMODE SYMBOL
    `(TAG ',$2 'quotemode)
  ;

start_decl:
    START symbols
    `(TAG ',(car $2) 'start :rest ',(cdr $2))
  ;

token_decl:
    TOKEN token_type_opt SYMBOL string_value
    `(TAG ',$3 ',(if $2 'token 'keyword) :type ',$2 :value ',$4)
  | TOKEN token_type_opt symbols
    `(TAG ',(car $3) 'token :type ',$2 :rest ',(cdr $3))
  ;

token_type_opt:
 ;; EMPTY
  | token_type
  ;

token_type:
    LT SYMBOL GT
    (progn $2)
  ;

use_macros_decl:
    USE-MACROS SYMBOL put_name_list
    (let* ((names (mapcar 'semantic-tag-name $3)))
      `(TAG "macro" 'macro :type ',$2 :value ',names))
  ;

;;; OBSOLETE Declarations
;;
keywordtable_decl:
    KEYWORDTABLE SYMBOL
    (progn
      (message "The %s keyword is obsolete and no more used" $1)
      nil)
  ;

outputfile_decl:
    OUTPUTFILE string_value
    (progn
      (message "The %s keyword is obsolete and no more used" $1)
      nil)
  ;

parsetable_decl:
    PARSETABLE SYMBOL
    (progn
      (message "The %s keyword is obsolete and no more used" $1)
      nil)
  ;

setupfunction_decl:
    SETUPFUNCTION SYMBOL
    (progn
      (message "The %s keyword is obsolete and no more used" $1)
      nil)
  ;

tokentable_decl:
    TOKENTABLE SYMBOL
    (progn
      (message "The %s keyword is obsolete and no more used" $1)
      nil)
  ;

string_value:
    STRING
    (read $1)
  ;

;; Return a Lisp readable form
any_value:
    SYMBOL
  | STRING
  | PAREN_BLOCK
  | PREFIXED_LIST
  | SEXP
  ;

symbols:
    lifo_symbols
    (nreverse $1)
  ;

lifo_symbols:
    lifo_symbols SYMBOL
    (cons $2 $1)
  | SYMBOL
    (list $1)
  ;

;;; Grammar rules
;;
nonterminal:
    SYMBOL COLON rules SEMI
    (TAG $1 'nonterminal :children $3)
  ;

rules:
    lifo_rules
    (apply 'nconc (nreverse $1))
  ;

lifo_rules:
    lifo_rules OR rule
    (cons $3 $1)
  | rule
    (list $1)
  ;

rule:
    rhs
    (let* ((rhs $1)
           name type comps prec action elt)
      (while rhs
        (setq elt (car rhs)
              rhs (cdr rhs))
        (cond
         ;; precedence level
         ((vectorp elt)
          (if prec
              (message "Duplicate %%prec in a rule, keep latest"))
          (setq prec (aref elt 0)))
         ;; action
         ((consp elt)
          (if (or action comps)
              ;; A mid-rule action
              (setq comps (cons elt comps))
            ;; The end-of-rule action
            (setq action (car elt))))
         ;; item
         (t
          (setq comps (cons elt comps)))))
      (if comps
          (setq type "group"
                name (mapconcat
                      #'(lambda (e) (if (consp e) "{}" e)) comps " "))
        (setq type "empty"
              name ";;EMPTY"))
      (EXPANDTAG
       (TAG name 'rule :type type :value comps :prec prec :expr action)
       ))
  ;

rhs:
 ;; EMPTY
  | rhs item
    (cons $2 $1)
  | rhs action
    (cons (list $2) $1)
  | rhs PREC item
    (cons (vector $3) $1)
  ;

action:
    PAREN_BLOCK
  | PREFIXED_LIST
  | BRACE_BLOCK
    (format "(progn\n%s)"
            (let ((s $1))
              (if (string-match "^{[\r\n\t ]*" s)
                  (setq s (substring s (match-end 0))))
              (if (string-match "[\r\n\t ]*}$" s)
                  (setq s (substring s 0 (match-beginning 0))))
              s))
  ;

items:
    lifo_items
    (nreverse $1)
  ;

lifo_items:
    lifo_items item
    (cons $2 $1)
  | item
    (list $1)
  ;

item:
    SYMBOL
  | CHARACTER
  ;

;;; semantic-grammar.wy ends here
