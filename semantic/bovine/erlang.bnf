# Erlang BNF language specification
#
# Copyright (C) 2002 Vladimir G. Sekissov
#
# Author: Vladimir G. Sekissov <svg@surnet.ru>
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Emacs; see the file COPYING.  If not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
# $Id: erlang.bnf,v 1.1 2003-01-30 11:58:42 zappo Exp $
#
%start         module-decl
%outputfile    semantic-erlang.el
%parsetable    semantic-toplevel-erlang-bovine-table
%keywordtable  semantic-erlang-keyword-table
%languagemode  erlang-mode
%setupfunction semantic-default-erlang-setup

%(setq semantic-symbol->name-assoc-list '( (variable . "Definitions")
					   (type     . "Records")
					   (function . "Functions")
					   (include  . "Includes")
					   (package  . "Module"))
       semantic-number-expression nil
       imenu-create-index-function 'semantic-create-imenu-index
       semantic-type-relation-separator-character '(".")
       semantic-command-separation-character ","
       semantic-ignore-comments t
       document-comment-start "%%**"
       document-comment-line-prefix "%%"
       document-comment-end "%%*"
       semantic-flex-syntax-modifications '((?' "_")
					    (?$ "/")
					    )
       semantic-flex-extensions
       `(("\\s/\\(\\(\\\\[0-9]\\{3\\}\\)\\|[^\\]\\|\\\\\\\\\\)"
	  . ,(lambda ()
	       (goto-char (match-end 0))
	       (cons 'CHAR (cons (match-beginning 0) (match-end 0))))))
       )%

%token BEGIN                 "begin"
%token END                   "end"
%token CASE                  "case"
%token OF                    "of"
%token IF                    "if"
%token WHEN                  "when"
%token TRUE                  "true"
%token RECEIVE               "receive" 
%token AFTER                 "after"
%token OR                    "or"
%token XOR                   "xor"
%token BOR                   "bor"
%token BXOR                  "bxor"
%token BSL                   "bsl"
%token BSR                   "bsr"
%token DIV                   "div"
%token REM                   "rem"
%token BAND                  "band"
%token AND                   "and"
%token BNOT                  "bnot"
%token NOT                   "not"
%token CATCH                 "catch"
%token FUN                   "fun"
%token QUERY                 "query"
%token LET                   "let"

%token MODULE                "module"  
%token INCLUDE               "include"
%token INCLUDE_LIB           "include_lib"
%token BEHAVIOUR             "behaviour"
%token DEFINE                "define"  
%token UNDEF                 "undef"
%token IFDEF                 "ifdef"
%token IFNDEF                "ifndef"
%token ELSE                  "else"
%token ENDIF                 "endif"
%token EXPORT                "export"  
%token IMPORT                "import"  
%token RECORD                "record"  

%token HASH      punctuation "#"
%token PERIOD    punctuation "."
%token COLON     punctuation ":"
%token SEMICOLON punctuation ";"
%token STAR      punctuation "*"
%token AMPERSAND punctuation "&"
%token DIVIDE    punctuation "/"
%token PLUS      punctuation "+"
%token MINUS     punctuation "-"
%token BANG      punctuation "!"
%token WHY       punctuation "?"
%token EQUAL     punctuation "="
%token LESS      punctuation "<"
%token GREATER   punctuation ">"
%token COMA      punctuation ","
%token VDEL      punctuation "|"
#%token DOLLAR    charquote   "$"

add-op : PLUS
       | MINUS
       | BOR
       | BXOR
       | BSL
       | BSR
       ;

list-conc-op : PLUS PLUS
             | MINUS MINUS
             ;

comp-op : EQUAL EQUAL
          ( "==" )
        | EQUAL COLON EQUAL
          ( "=:=" )
        | EQUAL DIVIDE EQUAL
          ( "=/=" )
        | DIVIDE EQUAL
          ( "/=" )
        | EQUAL LESS
          ( "=<" )
        | GREATER EQUAL
          ( ">=" )
        | LESS
        | GREATER
	| OR
	| AND
        ;

multi-op : STAR
        | DIVIDE
        | DIV
        | REM
        | BAND
        ;

prefix-op : PLUS
          | MINUS 
          | BNOT
         ;

basic-type : float-literal
	   | integer-literal
           | char-literal
           | atom
           | var
           | string
           | TRUE
           ;

atom : symbol "[a-z][a-zA-Z0-9_@]*"
       ( $1 )
     | symbol "'.+'"
       ( $1 )
     ;

float-literal : symbol "[0-9]+" PERIOD symbol "[0-9]+" exp-part
	      | PERIOD symbol "[0-9]+" exp-part
              ;

exp-part : symbol "[eE]" punctuation "[-+]" symbol "[0-9]+" 
         | symbol "[eE]" symbol "[0-9]+" 
         | EMPTY
         ;

integer-literal : symbol "[0-9a-eA-E]+"
                | symbol "[0-9]\\{1,2\\}" HASH "[0-9a-eA-E]+"
                ;

char-literal : CHAR
	     ;
var : symbol "^_[a-zA-Z0-9]+"
      ($1 variable nil nil nil nil)
    | symbol "^[A-Z][_a-zA-Z0-9]*"
      ($1 variable nil nil nil nil)
    ;

uni-pattern : symbol "_"
            ;

binary : LESS LESS GREATER GREATER
         ( "<<>>" binary nil nil )
       | LESS LESS binary-segments GREATER GREATER
         ( "<<Binary>>" binary nil nil)
       ;

binary-segments : binary-segment binary-segments-rest
                ;

binary-segments-rest : COMA binary-segments
                       ( ,$2 )
                     | EMPTY
                     ;

binary-segment : basic-type binary-segment-rest
               | expr binary-segment-rest
               ;

binary-segment-rest : COLON integer-literal DIVIDE basic-type
                    | COLON basic-type
                    | DIVIDE basic-type
                    | EMPTY
                    ;

module-decl : module-attr
            | function-decl
            | header-form
            | directive
            | file-attr
        ;

module-attr :  MINUS MODULE semantic-list "^(" full-stop
              ( (car (EXPAND $3 module-attr-name 2)) package nil nil )
	    ;

module-attr-name : open-paren "(" module-name close-paren ")"
		   ( (car $2) )
		 ;

module-name : atom module-name-rest
	      ( (concat (car $1) (car $2)) )
	    | module-name-rest
	      ( (car $1) )
	    ;

module-name-rest : PERIOD atom module-name-rest
		   ( (concat $1 (car $2) (car $3)) )
		 | EMPTY
		   ( nil )
		 ;

header-form : header-attr
            | anywhere-attr
            ;

header-attr : export-attr
            | import-attr
            | compile-attr
            | whild-attr
            ;

anywhere-attr : file-attr
              | macro-def
              | record-decl
              ;

export-attr :  MINUS EXPORT semantic-list  "^(" full-stop
            #( (car (EXPAND $3 export-name-list 1)) export nil nil )
            ;

export-name-list : open-paren semantic-list "^\\[" close-paren
                 # ( (car (EXPAND $2 function-name-list 1)) )
                 ;

import-attr : MINUS IMPORT semantic-list "^(" full-stop
              ( (car (EXPAND $3 import-name-list 1)) import nil nil )
            ;

import-name-list : open-paren module-name COMA semantic-list "^\\[" close-paren
                   ( ,$2 (EXPAND $4 function-name-list 1))
		 | open-paren module-name close-paren
		   ( ,$2 )
                 ;

function-name-list : open-paren close-paren
                     ( nil )
                   | open-paren function-names close-paren
                     ( $2 )
                   ;

function-names : function-arity COMA function-names
                 ( $1  $3 )
               | function-arity
                 ( $1 )
               ;

function-arity : atom DIVIDE integer-literal
                 ( ,$1 $2 ,$3 )
              ;

compile-attr : MINUS COMPILE semantic-list "^(" full-stop
             #( $3 compile nil nil )
	     ;

file-attr : MINUS symbol "file" semantic-list "^(" full-stop
          #( (car (EXPAND $3 file-attr-list 1)) file nil nil )
          ;

file-attr-list : open-paren string COMA integer-literal close-paren
                 ( (cons (read $2) ,$4) )
               ;

whild-attr : MINUS atom semantic-list "^(" full-stop
           # ( $3 (read (car $2)) nil nil )
          ;

function-decl : function-clauses full-stop
                ( ,$1 )
              ;

function-clauses : function-clause function-clauses-rest
                   ( ,$1 )
                 ;

function-clauses-rest : SEMICOLON function-clauses
                      | EMPTY
                      ;

function-clause : atom fun-clause
                  ( (concat (car $1) "/" (number-to-string (length (car $2))))
                    function nil ,$2 nil nil)
                ;

record-decl :  MINUS RECORD semantic-list "(" full-stop
              ( ,(car (EXPANDFULL $3 record-def 1)) )
            ;

record-def : open-paren atom COMA semantic-list "^{" close-paren
             (,$2 type "record" (EXPANDFULL $4 record-field-decl 1) nil nil)
           ;

record-decl-tuple : open-paren record-field-decls close-paren
                    ( $2 )
                  | open-paren close-paren
                    ( nil )
                  ;

record-field-decl : atom record-field-value
		    ( ,$1 variable nil "" () nil)
                  | atom
		    ( ,$1 variable nil "" () nil)
		  | open-paren "{"
		    ( nil )
		  | close-paren "}"
		    ( nil )
		  | COMA
		    ( nil )
                  ;

pattern : pattern-expr
          ( ,$1 )
        | uni-pattern
        | binary
        | basic-type
        | semantic-list "^\\["
          ( "List" list nil nil )
        # ( (EXPAND $1 list-pattern ) )
        | semantic-list "^{"
          ( "Tuple" tuple nil nil )
        # ( (EXPAND $1 tuple-pattern 1) )
        | record-pattern
          ( ,$1 )
        ;

pattern-expr : pattern-conc-expr pattern-conc-expr-rest
               ( ,$1 )
             ;

pattern-conc-expr : string-literal
                  | var
                  ;

pattern-conc-expr-rest : list-conc-op pattern-expr
                         ( )
                       | EMPTY
                       ;

tuple-pattern : open-paren patterns close-paren
              | open-paren close-paren
                ( nil )
              ;

list-pattern : open-paren patterns list-pattern-tail close-paren
              | open-paren close-paren
               ( nil )
              ;

list-pattern-tail : VDEL pattern
                  | EMPTY
                    ( nil )
                  ;

patterns : pattern patterns-rest
           ((cons (car $1) (car $2)))
         ;

patterns-rest : COMA patterns
                ( ,$2 )
              | EMPTY
              ;

record-pattern : HASH atom semantic-list "^{"
                 ( (car $2) )
               # ( (cons $2 (EXPAND $3 record-pattern-tuple 1) ) )
               ;

record-pattern-tuple : open-paren record-field-patterns close-paren
                       ( $2 )
                     | open-paren close-paren
                       ( nil )
                     ;

record-field-patterns : record-field-patterns COMA record-field-pattern
                      | record-field-pattern
                      ;

record-field-pattern : atom EQUAL pattern
                     ;

body : exprs
     ;

exprs : expr exprs-rest
      ;

exprs-rest : COMA exprs
           | EMPTY
           ;

expr : CATCH expr
     | match-expr
     ;

match-expr : pattern EQUAL match-expr
           | send-expr
           ;

send-expr : compare-expr send-expr-rest
          ;

send-expr-rest : BANG send-expr
               | EMPTY
               ;

compare-expr : list-conc-expr compare-expr-rest
             ;

compare-expr-rest : comp-op list-conc-expr
                  | EMPTY
                  ;

list-conc-expr : add-expr list-conc-expr-rest
               ;

list-conc-expr-rest : list-conc-op list-conc-expr
                    | EMPTY
                    ;

add-expr : multi-expr add-expr-rest
         ;

add-expr-rest : add-op add-expr
              | EMPTY
              ;

multi-expr : prefix-expr multi-expr-rest
           ;

multi-expr-rest : multi-op multi-expr
                | EMPTY
                ;

prefix-expr : prefix-op record-expr
            | record-expr
            ;

record-expr : HASH record-expr-field
            | application-expr record-expr-rest
            ;

record-expr-rest : HASH record-expr-field
                 | EMPTY
                 ;

record-expr-field : atom PERIOD atom
                  | atom semantic-list "^{"
                  # ( $1 (EXPAND $3 record-update-tuple 1) )
                  | record-expr
                  ;

record-update-tuple : open-paren close-paren
                    | open-paren record-field-updates close-paren
                    ;

record-field-updates : record-field-update record-field-updates-rest
                     ;

record-field-updates-rest : COMA record-field-updates
                          | EMPTY
                          ;

record-field-update : atom record-field-value
                    ;

record-field-value : EQUAL expr
                   | EMPTY
                   ;

application-expr : module-name COLON primary-expr semantic-list "^("
		 | primary-expr application-expr-rest
                 ;

application-expr-rest : semantic-list "^("
                      #( (EXPAND $1 application-expr-list 1) )
                      | COLON primary-expr semantic-list "^("
                      #( $1 $2 (EXPAND $3 application-expr-list 1) )
                      | EMPTY
                      ;

application-expr-list : open-paren close-paren
                      | open-paren exprs close-paren
                      ;

primary-expr : binary
             | string-literal
             | basic-type
	     #| module-name
             | semantic-list "^{"
             #  ( (EXPAND $1 tuple-skel 1) )
             | semantic-list "^\\["
             #  ( (EXPAND $1 list-skel 1) )
             | semantic-list "^\\["
             #  ( (EXPAND $1 list-compr 1) )
             | block-expr
             | if-expr
             | case-expr
             | receive-expr
             | fun-expr
             | query-expr
             | paren-expr
             ;

string-literal : string
               | macro-app
               | string string-literal
               ;

tuple-skel : open-paren close-paren
           | open-paren exprs close-paren
           ;

list-skel : open-paren close-paren
          | open-paren exprs list-skel-tail close-paren
           ;

list-skel-tail : VDEL expr
               | EMPTY
               ;

list-compr :  open-paren expr VDEL VDEL list-compr-exprs close-paren
           ;

list-compr-exprs : list-compr-expr list-compr-exprs-rest
                 ;

list-compr-exprs-rest : COMA list-compr-exprs
                      | EMPTY
                      ;

list-compr-expr : generator
                | filter
                ;

generator : pattern LESS MINUS expr
          ;

filter : expr
       ;

block-expr : BEGIN body END
           ;

if-expr : IF if-clauses END
        ;

if-clauses : if-clause SEMICOLON if-clauses
           | if-clause
           ;

if-clause : guard clause-body
	  | expr clause-body
          ;

clause-body : MINUS GREATER body
            ;

case-expr : CASE expr OF cr-clauses END
          ;

cr-clauses : cr-clause SEMICOLON cr-clauses
           | cr-clause
           ;

cr-clause : clause-pattern clause-guard clause-body
          ;

clause-guard : WHEN guard
             | EMPTY
             ;

receive-expr : RECEIVE cr-clauses receive-after END
             | RECEIVE receive-after END
             | RECEIVE cr-clauses AFTER expr clause-body END
             ;

receive-after : AFTER expr clause-body
              | EMPTY
              ;

fun-expr : FUN function-arity
         | FUN fun-clauses END
         ;

fun-clauses : fun-clause fun-clauses-rest
            ;

fun-clauses-rest : SEMICOLON fun-clauses
                 | EMPTY
                 ;

fun-clause : semantic-list "^(" clause-guard clause-body
             ( ,(car (EXPAND $1 clause-pattern-list 1)) )
           ;

clause-pattern-list : open-paren clause-patterns close-paren
                      ( $2 )
                    ;
clause-patterns : clause-pattern clause-patterns-rest
           ((cons (car $1) (car $2)))
         ;

clause-patterns-rest : COMA clause-patterns
                ( ,$2 )
              | EMPTY
              ;

clause-pattern : match-pattern
               | pattern
               ;

match-pattern : var EQUAL pattern
                ( ,$1 )
	      | pattern EQUAL var
                ( ,$1 )
              ;

query-expr : QUERY semantic-list "^\\[" END
           # ( $1 (EXPAND $2 list-compr) $3)
           ;

paren-expr : semantic-list "^("
           #  ( ,(EXPAND $1 paren-expr-list 1) )
           ;

paren-expr-list : open-paren expr close-paren
                ;

guard : guard-test guard-rest
      ;

guard-rest : COMA guard
           | SEMICOLON guard
           | EMPTY
           ;

guard-test : TRUE
           | guard-record-test
           | guard-term-cmp
           | guard-recognizer
           | semantic-list "^("
           #  ( (EXPAND $1 paren-guard-test 1 ) )
           ; 

guard-record-test : RECORD semantic-list "^("
                  #  ( ,(EXPAND $2 guard-record-test 1) )
                  | open-paren guard-expr COMA symbol close-paren
                  ;
 
guard-recognizer : symbol semantic-list "^("
                 #  ( ,(cons $1 ,(EXPAND $2 guard-expr 1) ) )
                 ;

guard-term-cmp : guard-expr guard-term-op guard-expr
               ;

guard-term-op : comp-op
              | EQUAL
              ;

paren-guard-test : open-paren guard-test close-paren
                 ;

guard-expr : guard-add-expr
           ;

guard-add-expr : guard-multi-expr guard-add-expr-rest
               ;

guard-add-expr-rest :  add-op guard-add-expr
                    | EMPTY
                    ;

guard-multi-expr : guard-prefix-expr guard-multi-expr-rest
                 ;

guard-multi-expr-rest :  multi-op guard-multi-expr
                      | EMPTY
                      ;

guard-prefix-expr : prefix-op guard-application-expr
                  | guard-application-expr
                  ;

guard-application-expr : atom semantic-list "^("
                       #  ( (cons $1 (EXPAND $2 guard-exprs-list 1) ) )
                       | guard-record-expr
                       | guard-primary-expr
                       ;

guard-exprs-list : open-paren close-paren
                 | open-paren guard-exprs close-paren
                 ;

guard-exprs : guard-expr guard-exprs-rest
            ;

guard-exprs-rest : COMA guard-exprs
                 | SEMICOLON guard-exprs
                 | EMPTY
                 ;

guard-record-expr : HASH atom PERIOD atom
                  | guard-primary-expr HASH atom PERIOD atom
                  ;

guard-primary-expr : basic-type
                   | macro-app
                   | semantic-list "^{"
                   #  ( ,(EXPAND $1 guard-tuple-skel 1 ) )
                   | semantic-list "^\\["
                   #  ( ,(EXPAND $1 guard-list-skel 1 ) )
                   | semantic-list "^("
                   #  ( ,(EXPAND $1 guard-paren-expr 1 ) )
             ;

guard-tuple-skel : open-paren close-paren
           | open-paren guard-exprs close-paren
           ;

guard-list-skel : open-paren close-paren
                | open-paren guard-exprs guard-list-skel-tail close-paren
                ;

guard-list-skel-tail : VDEL guard-expr
                     | EMPTY
                     ;

guard-paren-expr : open-paren guard-expr close-paren
                 ;

directive : macro-def
          | macro-undef
          | include-dir
          | include-lib-dir
          | ifdef-dir
          | ifndef-dir
          | else-dir
          | endif-dir
          ;

macro-def : MINUS DEFINE semantic-list "^(" full-stop
            ( ,(EXPAND $3 macro-def-list 1) )
          ;

macro-def-list : open-paren symbol macro-def-opt COMA macro-def-opt close-paren
		   ( $2 variable nil $5
			(ASSOC const t)
			nil
			)
               ;

macro-def-opt : semantic-list
              | expr
              | EMPTY
              ;

macro-undef : MINUS UNDEF semantic-list "^(" full-stop
          ;

macro-app : WHY symbol semantic-list "^("
          | WHY symbol
          ;

include-dir :  MINUS INCLUDE semantic-list "^(" full-stop
              ( (car (EXPAND $3 include-file-name 1)) include nil nil )
            ;

include-lib-dir : MINUS INCLUDE_LIB semantic-list "^(" full-stop
                  ( (car (EXPAND $3 include-file-name 1)) include nil nil )
                ;

include-file-name : open-paren string close-paren
                    ( (read $2) )
                  ;

ifdef-dir : MINUS IFDEF semantic-list "^(" full-stop
          #( ,(EXPAND $3 macro-name 1) )
          ;

ifndef-dir : MINUS IFNDEF semantic-list "^(" full-stop
           #( ,(EXPAND $3 macro-name 1) )
          ;

else-dir : MINUS ELSE full-stop
         ;

endif-dir : MINUS ENDIF full-stop
          ;

full-stop : PERIOD
          ;
