;;; wisent-java-tags.wy -- Semantic LALR grammar for Java
;;
;; Copyright (C) 2002 David Ponce
;;
;; Author: David Ponce <david@dponce.com>
;; Maintainer: David Ponce <david@dponce.com>
;; Created: 25 Feb 2002
;; Keywords: syntax
;; X-RCS: $Id: wisent-java-tags.wy,v 1.8 2003-04-02 10:17:34 ponced Exp $
;;
;; This file is not part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; --------
;; Settings
;; --------
%outputfile    "wisent-java-tags.el"
%parsetable    wisent-java-parser-tables
%keywordtable  wisent-java-keywords
%tokentable    wisent-java-tokens
%languagemode  java-mode
%setupfunction wisent-java-default-setup

;; The default start symbol
%start compilation_unit
;; Alternate entry points
;;    - Needed by partial re-parse
%start package_declaration
%start import_declaration
%start class_declaration
%start field_declaration
%start method_declaration
%start formal_parameter
%start constructor_declaration
%start interface_declaration
;;    - Needed by EXPANDFULL clauses
%start class_member_declaration
%start interface_member_declaration
%start formal_parameters

%{
  (setq
   ;; Lexical analysis
   semantic-lex-number-expression semantic-java-number-regexp
   semantic-lex-analyzer 'wisent-java-tags-lexer
   ;; Parsing
   semantic-tag-expand-function 'wisent-java-expand-tag
   ;; Environment
   semantic-imenu-summary-function 'semantic-prototype-nonterminal
   imenu-create-index-function 'semantic-create-imenu-index
   semantic-type-relation-separator-character '(".")
   semantic-command-separation-character ";"
   document-comment-start "/**"
   document-comment-line-prefix " *"
   document-comment-end " */"
   ;; speedbar and imenu buckets name
   semantic-symbol->name-assoc-list-for-type-parts
   ;; in type parts
   '((type     . "Classes")
     (variable . "Variables")
     (function . "Methods"))
   semantic-symbol->name-assoc-list
   ;; everywhere
   (append semantic-symbol->name-assoc-list-for-type-parts
           '((include  . "Imports")
             (package  . "Package")))
   ;; navigation inside 'type children
   senator-step-at-token-ids '(function variable)
   )
  ;; Setup javadoc stuff
  (semantic-java-doc-setup)
  %}

;; ;; Customize `wisent-flex' match algorithm 
;; ;; - Use string comparison for:
;; %put {punctuation open-paren close-paren} string t
;; ;; - An operator can be made of multiple successive punctuations
;; %put punctuation multiple t

;; ---------------------
;; Parenthesis terminals
;; ---------------------
%token <open-paren>   LPAREN           "("
%token <close-paren>  RPAREN           ")"
%token <open-paren>   LBRACE           "{"
%token <close-paren>  RBRACE           "}"
%token <open-paren>   LBRACK           "["
%token <close-paren>  RBRACK           "]"

;; ---------------
;; Block terminals
;; ---------------
%token <semantic-list> PAREN_BLOCK     "^("
%token <semantic-list> BRACE_BLOCK     "^{"
%token <semantic-list> BRACK_BLOCK     "^\\["

;; ------------------
;; Operator terminals
;; ------------------
%token <punctuation>   NOT             "!"
%token <punctuation>   NOTEQ           "!="
%token <punctuation>   MOD             "%"
%token <punctuation>   MODEQ           "%="
%token <punctuation>   AND             "&"
%token <punctuation>   ANDAND          "&&"
%token <punctuation>   ANDEQ           "&="
%token <punctuation>   MULT            "*"
%token <punctuation>   MULTEQ          "*="
%token <punctuation>   PLUS            "+"
%token <punctuation>   PLUSPLUS        "++"
%token <punctuation>   PLUSEQ          "+="
%token <punctuation>   COMMA           ","
%token <punctuation>   MINUS           "-"
%token <punctuation>   MINUSMINUS      "--"
%token <punctuation>   MINUSEQ         "-="
%token <punctuation>   DOT             "."
%token <punctuation>   DIV             "/"
%token <punctuation>   DIVEQ           "/="
%token <punctuation>   COLON           ":"
%token <punctuation>   SEMICOLON       ";"
%token <punctuation>   LT              "<"
%token <punctuation>   LSHIFT          "<<"
%token <punctuation>   LSHIFTEQ        "<<="
%token <punctuation>   LTEQ            "<="
%token <punctuation>   EQ              "="
%token <punctuation>   EQEQ            "=="
%token <punctuation>   GT              ">"
%token <punctuation>   GTEQ            ">="
%token <punctuation>   RSHIFT          ">>"
%token <punctuation>   RSHIFTEQ        ">>="
%token <punctuation>   URSHIFT         ">>>"
%token <punctuation>   URSHIFTEQ       ">>>="
%token <punctuation>   QUESTION        "?"
%token <punctuation>   XOR             "^"
%token <punctuation>   XOREQ           "^="
%token <punctuation>   OR              "|"
%token <punctuation>   OREQ            "|="
%token <punctuation>   OROR            "||"
%token <punctuation>   COMP            "~"

;; -----------------
;; Literal terminals
;; -----------------
%token <symbol>      IDENTIFIER
%token <string>      STRING_LITERAL
%token <number>      NUMBER_LITERAL

;; -----------------
;; Keyword terminals
;; -----------------
%token ABSTRACT     "abstract"
%put ABSTRACT summary
"Class|Method declaration modifier: abstract {class|<type>} <name> ..."

%token BOOLEAN      "boolean"
%put BOOLEAN summary
"Primitive logical quantity type (true or false)"

%token BREAK        "break"
%put BREAK summary
"break [<label>] ;"

%token BYTE         "byte"
%put BYTE summary
"Integral primitive type (-128 to 127)"

%token CASE         "case"
%put CASE summary
"switch(<expr>) {case <const-expr>: <stmts> ... }"

%token CATCH        "catch"
%put CATCH summary
"try {<stmts>} catch(<parm>) {<stmts>} ... "

%token CHAR         "char"
%put CHAR summary
"Integral primitive type ('\u0000' to '\uffff') (0 to 65535)"

%token CLASS        "class"
%put CLASS summary
"Class declaration: class <name>"

%token CONST        "const"
%put CONST summary
"Unused reserved word"

%token CONTINUE     "continue"
%put CONTINUE summary
"continue [<label>] ;"

%token DEFAULT      "default"
%put DEFAULT summary
"switch(<expr>) { ... default: <stmts>}"

%token DO           "do"
%put DO summary
"do <stmt> while (<expr>);"

%token DOUBLE       "double"
%put DOUBLE summary
"Primitive floating-point type (double-precision 64-bit IEEE 754)"

%token ELSE         "else"
%put ELSE summary
"if (<expr>) <stmt> else <stmt>"

%token EXTENDS      "extends"
%put EXTENDS summary
"SuperClass|SuperInterfaces declaration: extends <name> [, ...]"

%token FINAL        "final"
%put FINAL summary
"Class|Member declaration modifier: final {class|<type>} <name> ..."

%token FINALLY      "finally"
%put FINALLY summary
"try {<stmts>} ... finally {<stmts>}"

%token FLOAT        "float"
%put FLOAT summary
"Primitive floating-point type (single-precision 32-bit IEEE 754)"

%token FOR          "for"
%put FOR summary
"for ([<init-expr>]; [<expr>]; [<update-expr>]) <stmt>"

%token GOTO         "goto"
%put GOTO summary
"Unused reserved word"

%token IF           "if"
%put IF summary
"if (<expr>) <stmt> [else <stmt>]"

%token IMPLEMENTS   "implements"
%put IMPLEMENTS summary
"Class SuperInterfaces declaration: implements <name> [, ...]"

%token IMPORT       "import"
%put IMPORT summary
"Import package declarations: import <package>"

%token INSTANCEOF   "instanceof"

%token INT          "int"
%put INT summary
"Integral primitive type (-2147483648 to 2147483647)"

%token INTERFACE    "interface"
%put INTERFACE summary
"Interface declaration: interface <name>"

%token LONG         "long"
%put LONG summary
"Integral primitive type (-9223372036854775808 to 9223372036854775807)"

%token NATIVE       "native"
%put NATIVE summary
"Method declaration modifier: native <type> <name> ..."

%token NEW          "new"

%token PACKAGE      "package"
%put PACKAGE summary
"Package declaration: package <name>"

%token PRIVATE      "private"
%put PRIVATE summary
"Access level modifier: private {class|interface|<type>} <name> ..."

%token PROTECTED    "protected"
%put PROTECTED summary
"Access level modifier: protected {class|interface|<type>} <name> ..."

%token PUBLIC       "public"
%put PUBLIC summary
"Access level modifier: public {class|interface|<type>} <name> ..."

%token RETURN       "return"
%put RETURN summary
"return [<expr>] ;"

%token SHORT        "short"
%put SHORT summary
"Integral primitive type (-32768 to 32767)"

%token STATIC       "static"
%put STATIC summary
"Declaration modifier: static {class|interface|<type>} <name> ..."

%token STRICTFP     "strictfp"
%put STRICTFP summary
"Declaration modifier: strictfp {class|interface|<type>} <name> ..."

%token SUPER        "super"

%token SWITCH       "switch"
%put SWITCH summary
"switch(<expr>) {[case <const-expr>: <stmts> ...] [default: <stmts>]}"


%token SYNCHRONIZED "synchronized"
%put SYNCHRONIZED summary
"synchronized (<expr>) ... | Method decl. modifier: synchronized <type> <name> ..."

%token THIS         "this"

%token THROW        "throw"
%put THROW summary
"throw <expr> ;"

%token THROWS       "throws"
%put THROWS summary
"Method|Constructor declaration: throws <classType>, ..."

%token TRANSIENT    "transient"
%put TRANSIENT summary
"Field declaration modifier: transient <type> <name> ..."

%token TRY          "try"
%put TRY summary
"try {<stmts>} [catch(<parm>) {<stmts>} ...] [finally {<stmts>}]"

%token VOID         "void"
%put VOID summary
"Method return type: void <name> ..."

%token VOLATILE     "volatile"
%put VOLATILE summary
"Field declaration modifier: volatile <type> <name> ..."

%token WHILE        "while"
%put WHILE summary
"while (<expr>) <stmt> | do <stmt> while (<expr>);"
  
;; --------------------------
;; Official javadoc line tags
;; --------------------------

;; Javadoc tags are identified by a 'javadoc' keyword property.  The
;; value of this property must be itself a property list where the
;; following properties are recognized:
;;
;; - `seq' (mandatory) is the tag sequence number used to check if tags
;;   are correctly ordered in a javadoc comment block.
;;
;; - `usage' (mandatory) is the list of token categories for which this
;;   documentation tag is allowed.
;;
;; - `opt' (optional) if non-nil indicates this is an optional tag.
;;   By default tags are mandatory.
;;
;; - `with-name' (optional) if non-nil indicates that this tag is
;;   followed by an identifier like in "@param <var-name> description"
;;   or "@exception <class-name> description".
;;
;; - `with-ref' (optional) if non-nil indicates that the tag is
;;   followed by a reference like in "@see <reference>".

%token _AUTHOR      "@author"
%put   _AUTHOR      javadoc (seq 1 usage (type))
%token _VERSION     "@version"
%put   _VERSION     javadoc (seq 2 usage (type)) 
%token _PARAM       "@param"
%put   _PARAM       javadoc (seq 3 usage (function) with-name t) 
%token _RETURN      "@return"
%put   _RETURN      javadoc (seq 4 usage (function)) 
%token _EXCEPTION   "@exception"
%put   _EXCEPTION   javadoc (seq 5 usage (function) with-name t) 
%token _THROWS      "@throws"
%put   _THROWS      javadoc (seq 6 usage (function) with-name t) 
%token _SEE         "@see"
%put   _SEE         javadoc (seq 7 usage (type function variable) opt t with-ref t) 
%token _SINCE       "@since"
%put   _SINCE       javadoc (seq 8 usage (type function variable) opt t) 
%token _SERIAL      "@serial"
%put   _SERIAL      javadoc (seq 9 usage (variable) opt t) 
%token _SERIALDATA  "@serialData"
%put   _SERIALDATA  javadoc (seq 10 usage (function) opt t) 
%token _SERIALFIELD "@serialField"
%put   _SERIALFIELD javadoc (seq 11 usage (variable) opt t) 
%token _DEPRECATED  "@deprecated"
%put   _DEPRECATED  javadoc (seq 12 usage (type function variable) opt t) 

;; ------------
;; LALR Grammar
;; ------------

;; This grammar is not designed to fully parse correct Java syntax.  It
;; is optimized to work in an interactive environment to extract tokens
;; (tags) needed by Semantic.  In some cases a syntax not allowed by
;; the Java Language Specification will be accepted by this grammar.

compilation_unit
  : package_declaration
  | import_declaration
  | type_declaration
  ;

;;; Package statement token
;; ("NAME" package DETAIL "DOCSTRING")
package_declaration
  : PACKAGE qualified_name SEMICOLON
    (PACKAGE-TAG $2 nil)
  ;

;;; Include file token
;; ("FILE" include SYSTEM "DOCSTRING") 
import_declaration
  : IMPORT qualified_name SEMICOLON
    (INCLUDE-TAG $2 nil)
  | IMPORT qualified_name DOT MULT SEMICOLON
    (INCLUDE-TAG (concat $2 $3 $4) nil)
  ;

type_declaration
  : SEMICOLON
    ()
  | class_declaration
  | interface_declaration
  ;

;;; Type Declaration token
;; ("NAME" type "TYPE" ( PART-LIST ) ( PARENTS ) EXTRA-SPEC "DOCSTRING")
class_declaration
  : modifiers_opt CLASS qualified_name superc_opt interfaces_opt class_body
    (TYPE-TAG $3 $2 $6 (if (or $4 $5) (cons $4 $5)) 'typemodifiers $1)
  ;

superc_opt
  : ;;EMPTY
  | EXTENDS qualified_name
    (identity $2)
  ;

interfaces_opt
  : ;;EMPTY
  | IMPLEMENTS qualified_name_list
    (nreverse $2)
  ;

class_body
  : BRACE_BLOCK
    (EXPANDFULL $1 class_member_declaration)
  ;

class_member_declaration
  : LBRACE
    ()
  | RBRACE
    ()
  | block
    ()
  | static_initializer
    ()
  | constructor_declaration
  | interface_declaration
  | class_declaration
  | method_declaration
  | field_declaration
  ;

;;; Type Declaration token
;; ("NAME" type "TYPE" ( PART-LIST ) ( PARENTS ) EXTRA-SPEC "DOCSTRING")
interface_declaration
  : modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body
    (TYPE-TAG $3 $2 $5 (if $4 (cons nil $4)) 'typemodifiers $1)
  ;

extends_interfaces_opt
  : ;;EMPTY
  | EXTENDS qualified_name_list
    (identity $2)
  ;

interface_body
  : BRACE_BLOCK
    (EXPANDFULL $1 interface_member_declaration)
  ;

interface_member_declaration
  : LBRACE
    ()
  | RBRACE
    ()
  | interface_declaration
  | class_declaration
  | method_declaration
  | field_declaration
  ;

static_initializer
  : STATIC block
  ;

;;; Function token
;; ("NAME" function "TYPE" ( ARG-LIST ) EXTRA-SPEC "DOCSTRING") 
constructor_declaration
  : modifiers_opt constructor_declarator throwsc_opt constructor_body
    (FUNCTION-TAG (car $2) nil (cdr $2) 'typemodifiers $1 'throws $3)
  ;

constructor_declarator
  : IDENTIFIER formal_parameter_list
    (cons $1 $2)
  ;

constructor_body
  : block 
  ;

;;; Function token
;; ("NAME" function "TYPE" ( ARG-LIST ) EXTRA-SPEC "DOCSTRING") 
method_declaration
  : modifiers_opt VOID method_declarator throwsc_opt method_body
    (FUNCTION-TAG (car $3) $2 (cdr $3) 'typemodifiers $1 'throws $4)
  | modifiers_opt type method_declarator throwsc_opt method_body
    (FUNCTION-TAG (car $3) $2 (cdr $3) 'typemodifiers $1 'throws $4)
  ;

method_declarator
  : IDENTIFIER formal_parameter_list dims_opt
    (cons (concat $1 $3) $2)
  ;

throwsc_opt
  : ;;EMPTY
  | THROWS qualified_name_list
    (nreverse $2)
  ;

qualified_name_list
  : qualified_name_list COMMA qualified_name
    (cons $3 $1)
  | qualified_name
    (list $1)
  ;

method_body
  : SEMICOLON
  | block
  ;

;; Just eat {...} block!
block
  : BRACE_BLOCK
  ;

formal_parameter_list
  : PAREN_BLOCK
    (EXPANDFULL $1 formal_parameters)
  ;

formal_parameters
  : LPAREN
    ()
  | RPAREN
    ()
  | formal_parameter COMMA
  | formal_parameter RPAREN
  ;

;;; Variable token
;; ("NAME" variable "TYPE" DEFAULT-VALUE EXTRA-SPEC "DOCSTRING")
formal_parameter
  : formal_parameter_modifier_opt type variable_declarator_id
    (VARIABLE-TAG $3 $2 nil 'typemodifiers $1)
  ;

formal_parameter_modifier_opt
  : ;;EMPTY
  | FINAL
    (list $1)
  ;

;;; Variable token
;; ("NAME" variable "TYPE" DEFAULT-VALUE EXTRA-SPEC "DOCSTRING")
field_declaration
  : modifiers_opt type variable_declarators SEMICOLON
    (VARIABLE-TAG $3 $2 nil 'typemodifiers $1)
  ;

variable_declarators
  : variable_declarators COMMA variable_declarator
    (cons $3 $1)
  | variable_declarator
    (list $1)
  ;

variable_declarator
  : variable_declarator_id EQ variable_initializer
    (cons $1 $region)
  | variable_declarator_id
    (cons $1 $region)
  ;

variable_declarator_id
  : IDENTIFIER dims_opt
    (concat $1 $2)
  ;

variable_initializer
  : expression
  ;

;; Just eat expression!
expression
  : expression term
  | term
  ;

term
  : literal
  | operator
  | primitive_type
  | IDENTIFIER
  | BRACK_BLOCK
  | PAREN_BLOCK
  | BRACE_BLOCK
  | NEW
  | CLASS
  | THIS
  | SUPER
  ;

literal
;;   : NULL_LITERAL
;;   | BOOLEAN_LITERAL
  : STRING_LITERAL
  | NUMBER_LITERAL
  ;

operator
  : NOT
  | PLUS
  | PLUSPLUS
  | MINUS
  | MINUSMINUS
  | NOTEQ
  | MOD
  | MODEQ
  | AND
  | ANDAND
  | ANDEQ
  | MULT
  | MULTEQ
  | PLUSEQ
  | MINUSEQ
  | DOT
  | DIV
  | DIVEQ
  | COLON
  | LT
  | LSHIFT
  | LSHIFTEQ
  | LTEQ
  | EQ
  | EQEQ
  | GT
  | GTEQ
  | RSHIFT
  | RSHIFTEQ
  | URSHIFT
  | URSHIFTEQ
  | QUESTION
  | XOR
  | XOREQ
  | OR
  | OREQ
  | OROR
  | COMP
  | INSTANCEOF
  ;

primitive_type
  : BOOLEAN
  | CHAR
  | LONG
  | INT
  | SHORT
  | BYTE
  | DOUBLE
  | FLOAT
  ;

modifiers_opt
  : ;;EMPTY
  | modifiers
    (nreverse $1)
  ;

modifiers
  : modifiers modifier
    (cons $2 $1)
  | modifier
    (list $1)
  ;

modifier
  : STRICTFP
  | VOLATILE
  | TRANSIENT
  | SYNCHRONIZED
  | NATIVE
  | FINAL
  | ABSTRACT
  | STATIC
  | PRIVATE
  | PROTECTED
  | PUBLIC
  ;

type
  : qualified_name dims_opt
    (concat $1 $2)
  | primitive_type dims_opt
    (concat $1 $2)
  ;

qualified_name
  : qualified_name DOT IDENTIFIER
    (concat $1 $2 $3)
  | IDENTIFIER
  ;

dims_opt
  : ;;EMPTY
    (identity "")
  | dims
  ;

dims
  : dims BRACK_BLOCK
    (concat $1 "[]")
  | BRACK_BLOCK
    (identity "[]")
  ;

;;; wisent-java-tags.wy ends here
