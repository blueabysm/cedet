;;; wisent-wy.wy -- LALR grammar of Wisent's input grammar
;;
;; Copyright (C) 2002 David Ponce
;;
;; Author: David Ponce <david@dponce.com>
;; Maintainer: David Ponce <david@dponce.com>
;; Created: 19 Feb 2002
;; Keywords: syntax
;; X-RCS: $Id: wisent-wy.wy,v 1.4 2002-02-28 21:25:10 ponced Exp $
;;
;; This file is not part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

%{
  (setq semantic-number-expression
        ;; Numbers
        (concat "[-+]?\\([0-9]+\\([.][0-9]*\\)?\\([eE][-+]?[0-9]+\\)?"
                "\\|[.][0-9]+\\([eE][-+]?[0-9]+\\)?\\)")
        ;; C-like character literals
        semantic-flex-extensions wisent-wy-flex-extensions
        ;; Parent/Child separator
        semantic-type-relation-separator-character '(":")
        ;; Names
        semantic-symbol->name-assoc-list
        '(
          (code         . "Setup Code")
          (keyword      . "Keyword")
          (token        . "Token")
          (nonterminal  . "Nonterminal")
          (rule         . "Rule")
          )
        ;; Faces
        semantic-face-alist
        '(
          (code         . default)
          (keyword      . font-lock-keyword-face)
          (token        . font-lock-type-face)
          (nonterminal  . font-lock-function-name-face)
          (rule         . default)
          )
        )

  (semantic-install-function-overrides
   '(
     ;;(abbreviate-nonterminal    . wisent-wy-abbreviate-nonterminal)
     ;;(summarize-nonterminal     . wisent-wy-summarize-nonterminal)
     ;;(eldoc-current-symbol-info . wisent-wy-ecsi)
     (nonterminal-children      . wisent-wy-nonterminal-children)
     )
   t)
		    
  %}

%outputfile    "wisent-wy.el"
%parsetable    wisent-wy-automaton
%keywordtable  wisent-wy-keywords
%tokentable    wisent-wy-tokens
%languagemode  wy-mode
%setupfunction wisent-wy-setup-semantic

;; Main
%start grammar
;; Reparse
%start code declaration nonterminal rule
;; EXPANDFULL
%start put_names put_values

;; Keywords
%token LEFT          "left"
%token NONASSOC      "nonassoc"
%token PREC          "prec"
%token PUT           "put"
%token RIGHT         "right"
%token START         "start"
%token TOKEN         "token"
%token LANGUAGEMODE  "languagemode"
%token OUTPUTFILE    "outputfile"
%token SETUPFUNCTION "setupfunction"
%token KEYWORDTABLE  "keywordtable"
%token PARSETABLE    "parsetable"
%token TOKENTABLE    "tokentable"

;; Literals
%token <string>        STRING
%token <symbol>        SYMBOL
%token <number>        NUMBER
%token <char>          CHARACTER

;; Blocks
%token <semantic-list> PAREN_BLOCK "^("
%token <semantic-list> BRACE_BLOCK "^{"

;; Parens
%token <open-paren>    LBRACE      "{"
%token <close-paren>   RBRACE      "}"

;; Punctuations
%token <punctuation>   COLON       ":"
%token <punctuation>   SEMI        ";"
%token <punctuation>   OR          "|"
%token <punctuation>   LT          "<"
%token <punctuation>   GT          ">"
%token <punctuation>   PERCENT     "%"

;; Use string comparison for the following type of tokens
%put {punctuation open-paren close-paren} string t

%%

grammar:
    PERCENT
    ()
  | code
  | declaration
  | nonterminal
  ;

;; code token:
;; -----------
;;  ("code" 'code nil LISP-CALL-EXPRESSION nil)
;;
code:
    PAREN_BLOCK
    (wisent-token "code" 'code nil $1 nil)
  | BRACE_BLOCK
    (wisent-token "code" 'code nil $1 nil)
  ;

declaration:
    decl
    (apply #'wisent-token $1)
  ;

decl:
    languagemode_decl
  | outputfile_decl
  | setupfunction_decl
  | keywordtable_decl
  | parsetable_decl
  | tokentable_decl
  | token_decl
  | start_decl
  | left_decl
  | right_decl
  | nonassoc_decl
  | put_decl
  ;

;; languagemode token:
;; -------------------
;;  (FIRST-MODE-NAME 'languagemode nil REST-MODE-NAMES nil)
;;
languagemode_decl:
    LANGUAGEMODE symbols
    (list (car $2) 'languagemode nil (cdr $2) nil)
  ;

;; outputfile token:
;; -----------------
;;  (FILE-NAME 'outputfile nil nil)
;;
outputfile_decl:
    OUTPUTFILE string_value
    (list $2 'outputfile nil nil)
  ;

string_value:
    STRING
    (read $1)
  ;

;; setupfunction token:
;; --------------------
;;  (FUNC-NAME 'setupfunction nil nil)
;;
setupfunction_decl:
    SETUPFUNCTION any_symbol
    (list $2 'setupfunction nil nil)
  ;

;; keywordtable token:
;; -------------------
;;  (VAR-NAME 'keywordtable nil nil)
;;
keywordtable_decl:
    KEYWORDTABLE any_symbol
    (list $2 'keywordtable nil nil)
  ;

;; parsetable token:
;; -----------------
;;  (VAR-NAME 'parsetable nil nil)
;;
parsetable_decl:
    PARSETABLE any_symbol
    (list $2 'parsetable nil nil)
  ;

;; tokentable token:
;; -----------------
;;  (VAR-NAME 'tokentable nil nil)
;;
tokentable_decl:
    TOKENTABLE any_symbol
    (list $2 'tokentable nil nil)
  ;

;; token token:
;; ------------
;;  (FIRST-TOKEN-NAME 'token TYPE REST-TOKEN-NAMES VALUE nil)
;;
;; keyword token:
;; --------------
;;  (KEYWORD-NAME 'keyword nil nil KEYWORD-VALUE nil)
;;
token_decl:
    TOKEN token_type_opt any_symbol string_value
    (list $3 (if $2 'token 'keyword) $2 nil $4 nil)
  | TOKEN token_type_opt symbols
    (list (car $3) 'token $2 (cdr $3) nil nil)
  ;

token_type_opt:
  ;; EMPTY
  | token_type
  ;

token_type:
    LT any_symbol GT
    (identity $2)
  ;

;; start token:
;; ------------
;;  (FIRST-SYMBOL-NAME 'start nil REST-SYMBOL-NAMES nil)
;;
start_decl:
    START symbols
    (list (car $2) 'start nil (cdr $2) nil)
  ;

;; left token:
;; -----------
;;  ("left" 'assoc TYPE ITEMS nil)
;;
left_decl:
    LEFT token_type_opt items
    (list $1 'assoc $2 $3 nil)
  ;

;; right token:
;; ------------
;;  ("right" 'assoc TYPE ITEMS nil)
;;
right_decl:
    RIGHT token_type_opt items
    (list $1 'assoc $2 $3 nil)
  ;

;; nonassoc token:
;; ---------------
;;  ("nonassoc" 'assoc TYPE ITEMS nil)
;;
nonassoc_decl:
    NONASSOC token_type_opt items
    (list $1 'assoc $2 $3 nil)
  ;

;; put token:
;; ----------
;;  (FIRST-SYMBOL-NAME 'put nil REST-SYMBOL-NAMES PLIST nil)
;;
put_decl:
    PUT any_symbol put_value
    (list $2 'put nil nil (list $3) nil)
  | PUT any_symbol put_value_list
    (let* ((vals (mapcar #'(lambda (tok) (nth 3 tok)) $3)))
      (list $2 'put nil nil vals nil))
  | PUT put_name_list put_value
    (let* ((names (mapcar #'semantic-token-name $2)))
      (list (car names) 'put nil (cdr names) (list $3) nil))
  | PUT put_name_list put_value_list
    (let* ((names (mapcar #'semantic-token-name $2))
           (vals  (mapcar #'(lambda (tok) (nth 3 tok)) $3)))
      (list (car names) 'put nil (cdr names) vals nil))
  ;

put_name_list:
    BRACE_BLOCK
    (EXPANDFULL $1 put_names)
  ;

put_names:
    LBRACE
    ()
  | RBRACE
    ()
  | any_symbol
 ;; Must return a list of Semantic tokens to EXPANDFULL!
    (list (list $1 'put-name nil nil))
  ;

put_value_list:
    BRACE_BLOCK
    (EXPANDFULL $1 put_values)
  ;

put_values:
    LBRACE
    ()
  | RBRACE
    ()
  | put_value
 ;; Must return a list of Semantic tokens to EXPANDFULL!
    (list (list "" 'put-value nil $1 nil))
  ;

put_value:
    any_symbol any_value
    (cons $1 $2)
  ;

;; Return a Lisp readable form
any_value:
    any_symbol
  | STRING
  | NUMBER
  | PAREN_BLOCK
  ;

symbols:
    lifo_symbols
    (nreverse $1)
  ;

lifo_symbols:
    lifo_symbols any_symbol
    (cons $2 $1)
  | any_symbol
    (list $1)
  ;

;; nonterminal token:
;; ------------------
;;  (NONTERMINAL-NAME 'nonterminal nil RULE-TOKENS nil)
;;
nonterminal:
    any_symbol COLON rules SEMI
    (wisent-token $1 'nonterminal nil $3 nil)
  | error SEMI
  ;

rules:
    lifo_rules
    (apply #'nconc (nreverse $1))
  ;

lifo_rules:
    lifo_rules OR rule
    (cons $3 $1)
  | rule
    (list $1)
  ;

;; rule token:
;; ----------
;; EMPTY rule
;;    ("empty" 'rule nil nil ACTION PREC nil)
;; Other rule
;;    (RULE-NAME 'rule nil ELEMENTS ACTION PREC nil)
;; where:
;;  ELEMENTS is a list of ([MID-ACTION|nil] . TERM)
;;
;; THIS GRAMMAR NOT ALLOWS A MID-RULE ACTION AT THE END OF A RULE!
;;
rule:
 ;; EMPTY
    (wisent-token "empty" 'rule nil nil nil nil nil)
  | action
    (wisent-token "empty" 'rule nil nil $1 nil nil)
  | level action
    (wisent-token "empty" 'rule nil nil $2 $1 nil)
  | elements action_opt
    (let ((elts (nreverse $1)))
      (wisent-token (mapconcat #'cdr elts " ")
                    'rule nil elts $2 nil nil))
  | elements level action_opt
    (let ((elts (nreverse $1)))
      (wisent-token (mapconcat #'cdr elts " ")
                    'rule nil elts $3 $2 nil))
  ;

level:
    PERCENT PREC item
    (identity $3)
  ;
       
action_opt:
 ;; EMPTY
  | action
  ;

action:
    PAREN_BLOCK
  | BRACE_BLOCK
    (format "(progn\n%s)"
            (let ((s $1))
              (if (string-match "^{[\r\n\t ]*" s)
                  (setq s (substring s (match-end 0))))
              (if (string-match "[\r\n\t ]*}$" s)
                  (setq s (substring s 0 (match-beginning 0))))
              s))
  ;

elements:
    elements element
    (cons $2 $1)
  | element
    (list $1)
  ;

element:
    action_opt item
    (cons $1 $2)
  ;

items:
    lifo_items
    (nreverse $1)
  ;

lifo_items:
    lifo_items item
    (cons $2 $1)
  | item
    (list $1)
  ;

item:
    any_symbol
  | CHARACTER
  ;

any_symbol:
    SYMBOL
 ;; Keywords are reserved symbols only when they follow PERCENT!
  | LEFT
  | NONASSOC
  | PREC
  | PUT
  | RIGHT
  | START
  | TOKEN
  | LANGUAGEMODE
  | OUTPUTFILE
  | SETUPFUNCTION
  | KEYWORDTABLE
  | PARSETABLE
  | TOKENTABLE
  ;


;;; wisent-wy.wy ends here
