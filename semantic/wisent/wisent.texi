\input texinfo   @c -*-texinfo-*-
@c
@c $Id: wisent.texi,v 1.19 2003-02-24 08:05:05 ponced Exp $
@c
@setfilename wisent.info
@settitle Wisent: the Bison-compatible Parser Generator for Emacs

@copying
This manual documents Wisent, the Bison-compatible Parser Generator
for Emacs.

Copyright @copyright{} 2001, 2002, 2003 David Ponce

Some texts are borrowed or adapted from the manual of Bison version
1.35.  The text in section entitled ``Understanding the automaton'' is
adapted from the section ``Understanding Your Parser'' in the manual
of Bison version 1.49.

Copyright @copyright{} 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1998,
1999, 2000, 2001, 2002 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being list their titles, with the Front-Cover Texts
being list, and with the Back-Cover Texts being list.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.
@end quotation
@end copying

@dircategory Emacs
@direntry
* Wisent: (wisent).	The Bison-compatible Parser Generator for Emacs
@end direntry

@c Combine indices.
@synindex cp fn
@syncodeindex vr fn
@syncodeindex ky fn
@syncodeindex pg fn

@titlepage
@sp 6
@center @titlefont{Wisent Manual}
@sp 4
@author David Ponce (@email{david@dponce.com})
@page
@vskip 0pt plus 1 fill
@insertcopying
@end titlepage
@page

@node Top
@top Wisent

Wisent (the European Bison ;-) is an Emacs Lisp implementation of the
GNU Compiler Compiler Bison.

This manual describes how to use Wisent to develop grammars for
programming languages, and how to use grammars to parse language
source in Emacs buffers.

It also describes how Wisent is used with the Semantic tool set
described in the @ref{Top, Semantic Manual, Semantic Manual, semantic}.

@menu
* Overview::                    
* Grammar::                     
* Parsing::                     
* Wisent Semantic::             
* GNU Free Documentation License::  
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Grammar

* Grammar format::              
* Example::                     
* Compiling a grammar::         
* Conflicts::                   

Conflicts

* Grammar Debugging::           
* Understanding the automaton::  

Parsing

* Writing a lexer::             
* Actions goodies::             
* Report errors::               
* Error recovery::              
* Debugging actions::           

How to use Wisent with Semantic

* WY grammar format::           
* WY Major Mode::               
* Grammar styles::              
* Wisent Lex::                  

WY grammar format

* Percent-keywords::            

Grammar styles

* Iterative style::             
* Bison style::                 
* Mixed style::                 
* Start nonterminals::          
* Useful functions::            

@end detailmenu
@end menu

@node Overview
@chapter Overview

@dfn{Wisent} (the European Bison) is an implementation in Emacs Lisp
of the GNU Compiler Compiler Bison. Its code is a port of the C code
of GNU Bison 1.28 & 1.31.

For more details on the basic concepts for understanding Wisent, it is
worthwhile to read the @ref{Top, Bison Manual, bison}.
@ifhtml
@uref{http://www.gnu.org/manual/bison/html_node/index.html}.
@end ifhtml

Wisent can generate compilers compatible with the Semantic tool set.
See the @ref{Top, Semantic Manual, , semantic}.

It benefits from these Bison features:

@itemize @bullet
@item 
It uses a fast but not so space-efficient encoding for the parse
tables, described in Corbett's PhD thesis from Berkeley:
@quotation
@cite{Static Semantics in Compiler Error Recovery}@*
June 1985, Report No. UCB/CSD 85/251.
@end quotation

@item 
For generating the lookahead sets, Wisent uses the well-known
technique of F. DeRemer and A. Pennello they described in:
@quotation
@cite{Efficient Construction of LALR(1) Lookahead Sets}@*
October 1982, ACM TOPLS Vol 4 No 4.
@end quotation

@item 
Wisent resolves shift/reduce conflicts using operator precedence and
associativity.

@item 
Parser error recovery is accomplished using rules which match the
special token @code{error}.
@end itemize

Nevertheless there are some fundamental differences between Bison and
Wisent.

@itemize
@item
Wisent is intended to be used in Emacs.  It reads and produces Emacs
Lisp data structures.  All the additional code used in grammars is
Emacs Lisp code.

@item
Contrary to Bison, Wisent does not generate a parser which combines
Emacs Lisp code and grammar constructs.  They exist separately.
Wisent reads the grammar from a Lisp data structure and then generates
grammar constructs as tables.  Afterward, the derived tables can be
included and byte-compiled in separate Emacs Lisp files, and be used
at a later time by the Wisent's parser engine.

@item
Wisent allows multiple start nonterminals and allows a call to the
parsing function to be made for a particular start nonterminal.  For
example, this is particularly useful to parse a region of an Emacs
buffer.  Semantic heavily depends on the availability of this feature.
@end itemize

@node Grammar
@chapter Grammar

@cindex context-free grammar
@cindex rule
In order for Wisent to parse a language, it must be described by a
@dfn{context-free grammar}.  That is a grammar specified as rules that
can be applied regardless of context.  For more information, see
@ref{Language and Grammar, , , bison}, in the Bison manual.

@cindex terminal
@cindex nonterminal
The formal grammar is formulated using @dfn{terminal} and
@dfn{nonterminal} items.  Terminals can be Emacs Lisp symbols or
characters, and nonterminals are symbols only.

@cindex token
Terminals (also known as @dfn{tokens}) represent the lexical
elements of the language like numbers, strings, etc..

For example @samp{PLUS} can represent the operator @samp{+}.

Nonterminal symbols are described by rules:

@example
@group
RESULT @equiv{} COMPONENTS@dots{}
@end group
@end example

@samp{RESULT} is a nonterminal that this rule describes and
@samp{COMPONENTS} are various terminals and nonterminals that are put
together by this rule.

For example, this rule:

@example
@group
exp @equiv{} exp PLUS exp
@end group
@end example

Says that two groupings of type @samp{exp}, with a @samp{PLUS} token
in between, can be combined into a larger grouping of type @samp{exp}.
 
@menu
* Grammar format::              
* Example::                     
* Compiling a grammar::         
* Conflicts::                   
@end menu

@node Grammar format
@section Grammar format

@cindex grammar format
To be acceptable by Wisent a context-free grammars must respect a
particular format.  That is, must be represented as an Emacs Lisp list
of the form:

@code{(@var{terminals} @var{assocs} . @var{non-terminals})}

@table @var
@item terminals
Is the list of terminal symbols used in the grammar.

@cindex associativity
@item assocs
Specify the associativity of terminals.  It is @code{nil} when there
is no associativity defined, or a list of elements of the form:

@code{(@var{assoc-type} . @var{assoc-terms})}

Where @var{assoc-type} is the symbol @code{nonassoc}, @code{left} or
@code{right}, and @var{assoc-terms} is a list of terminal items.

For details, see @ref{Contextual Precedence, , , bison}, in the
Bison manual.

@item non-terminals
Is the list of nonterminal definitions.  Each definition has the form:

@code{(@var{nonterm} . @var{rules})}

Where @var{nonterm} is the nonterminal symbol defined and
@var{rules} the list of rules that describe this nonterminal.  Each
rule is a list:

@code{(@var{components} [@var{precedence}] [@var{action}])}

Where:

@table @var
@item components
Is a list of various terminals and nonterminals that are put together
by this rule.

For example,

@example
@group
(exp ((exp ?+ exp))          ;; exp: exp '+' exp
     )                       ;;    ;
@end group
@end example

Says that two groupings of type @samp{exp}, with a @samp{+} token in
between, can be combined into a larger grouping of type @samp{exp}.
 
@cindex grammar coding conventions
By convention, a nonterminal symbol should be in lower case, such as
@samp{exp}, @samp{stmt} or @samp{declaration}.  Terminal symbols
should be upper case to distinguish them from nonterminals: for
example, @samp{INTEGER}, @samp{IDENTIFIER}, @samp{IF} or
@samp{RETURN}.  A terminal symbol that represents a particular keyword
in the language is conventionally the same as that keyword converted
to upper case.  The terminal symbol @code{error} is reserved for error
recovery.

@cindex middle-rule actions
Scattered among the components can be @dfn{middle-rule} actions.
Usually only @var{action} is provided (@pxref{action}).

If @var{components} in a rule is @code{nil}, it means that the rule
can match the empty string.  For example, here is how to define a
comma-separated sequence of zero or more @samp{exp} groupings:

@example
@group
(expseq  (nil)               ;; expseq: ;; empty
         ((expseq1))         ;;       | expseq1
         )                   ;;       ;

(expseq1 ((exp))             ;; expseq1: exp
         ((expseq1 ?, exp))  ;;        | expseq1 ',' exp
         )                   ;;        ;
@end group
@end example

@cindex precedence level
@item precedence
Is an optional vector of one terminal item.  The rule will be given
the precedence level of this terminal.  Notice that only terminals
declared in @var{assocs} have a precedence level.  By default the rule
precedence is the one of the last terminal in it.
For details, see @ref{Contextual Precedence, , , bison}, in the
Bison manual.

It is important to understand that @var{assocs} declarations defines
associativity but also assign a precedence level to terminals.  All
terminals declared in the same @code{left}, @code{right} or
@code{nonassoc} association get the same precedence level.  The
precedence level is increased at each new association.

On the other hand, @var{precedence} explicitly assign the precedence
level of the given terminal to a rule.

@cindex semantic actions
@item @anchor{action}action
An action is an optional Emacs Lisp function call, like this:

@code{(identity $1)}

The result of an action determines the semantic value of a rule.

From an implementation standpoint, the function call will be embedded
in a lambda expression, and several useful local variables will be
defined:

@table @code
@vindex $N
@item $N
Where @var{n} is a positive integer.  Like in Bison, the value of
@code{$N} is the semantic value of the @var{n}th element of
@var{components}, starting from @code{1}.  It can be of any Lisp data
type.

@vindex $regionN
@item $regionN
Where @var{n} is a positive integer.  For each @code{$N} variable
defined there is a corresponding @code{$regionN} variable.  Its value
is a pair @code{(@var{start-pos} .  @var{end-pos})} that represent the
start and end positions (in the lexical input stream) of the @code{$N}
value.  It can be @code{nil} when the component positions are not
available, like for an empty string component for example.

@vindex $region
@item $region
Its value is the leftmost and rightmost positions of input data
matched by all @var{components} in the rule.  This is a pair
@code{(@var{leftmost-pos} .  @var{rightmost-pos})}.  It can be
@code{nil} when components positions are not available.

@vindex $nterm
@item $nterm
This variable is initialized with the nonterminal symbol
(@var{nonterm}) the rule belongs to.  It could be useful to improve
error reporting or debugging.  It is also used to automatically
provide the @code{reparse-symbol} property of a Semantic token
generated by the function @code{wisent-cooked-token}.  See
@ref{Wisent Semantic}, for details.

@vindex $action
@item $action
The value of @code{$action} is a string: the symbolic name of the
current semantic action (@pxref{Debugging actions}).
@end table

When an action is not specified a default value is supplied, it is
@code{(identity $1)}.  This means that the default semantic value of a
rule is the value of its first component.  Excepted for a rule
matching the empty string, for which the default action is to return
@code{nil}: @code{(identity nil)}.
@end table
@end table

@node Example
@section Example

@cindex grammar example
Here is an example to parse simple infix arithmetic expressions.  See
@ref{Infix Calc, , , bison}, in the Bison manual for details.

The full grammar in @dfn{WY} format (@pxref{WY grammar format}) is
available in the file @file{wisent-calc.wy}.

@example
@group
%token <number> NUM

%nonassoc '=' ;; comparison
%left '-' '+'
%left '*' '/'
%left NEG     ;; negation--unary minus
%right '^'    ;; exponentiation

%%

input:
    line
  | input line
    (format "%s %s" $1 $2)
  ;

line:
    ';'
    @{";"@}
  | exp ';'
    (format "%s;" $1)
  ;

exp:
    NUM
    (string-to-number $1)
  | exp '=' exp
    (= $1 $3)
  | exp '+' exp
    (+ $1 $3)
  | exp '-' exp
    (- $1 $3)
  | exp '*' exp
    (* $1 $3)
  | exp '/' exp
    (/ $1 $3)
  | '-' exp %prec NEG
    (- $2)
  | exp '^' exp
    (expt $1 $3)
  | '(' exp ')'
    @{$2@}
  ;

%%
@end group
@end example

Here is the corresponding Lisp form accepted by Wisent:

@lisp
@group
'(
  ;; Terminals
  (NUM)
  
  ;; Terminal associativity & precedence
  ((nonassoc ?=)
   (left ?- ?+)
   (left ?* ?/)
   (left NEG)
   (right ?^))
  
  ;; Rules
  (input
   ((line))
   ((input line)
    (format "%s %s" $1 $2))
   )

  (line
   ((?;)
    (progn ";"))
   ((exp ?;)
    (format "%s;" $1))
   )

  (exp
   ((NUM)
    (string-to-number $1))
   ((exp ?= exp)
    (= $1 $3))
   ((exp ?+ exp)
    (+ $1 $3))
   ((exp ?- exp)
    (- $1 $3))
   ((exp ?* exp)
    (* $1 $3))
   ((exp ?/ exp)
    (/ $1 $3))
   ((?- exp) [NEG]
    (- $2))
   ((exp ?^ exp)
    (expt $1 $3))
   ((?\( exp ?\))
    (progn $2))
   )
  )
@end group
@end lisp

@node Compiling a grammar
@section Compiling a grammar

@cindex automaton
After providing a context-free grammar in a suitable format, it must
be translated into a set of tables (an @dfn{automaton}) that will be
used to drive the parser.  Like Bison, Wisent translates grammars that
must be @dfn{LALR(1)}.

@cindex LALR(1) grammar
@cindex look-ahead token
A grammar is LALR(1) if it is possible to tell how to parse any
portion of an input string with just a single token of look-ahead: the
@dfn{look-ahead token}.  See @ref{Language and Grammar, , , bison}, in
the Bison manual for more information.

@cindex grammar compilation
Grammar translation (compilation) is achieved by the function:

@cindex compiling a grammar
@findex wisent-compile-grammar
@vindex wisent-single-start-flag
@defun wisent-compile-grammar grammar &optional start-list
Compile @var{grammar} and return an LALR(1) automaton.

Optional argument @var{start-list} is a list of start symbols
(nonterminals).  If @code{nil} the first nonterminal defined in the
grammar is the default start symbol.  If @var{start-list} contains
only one element, it defines the start symbol.  If @var{start-list}
contains more than one element, all are defined as potential start
symbols, unless @code{wisent-single-start-flag} is non-@code{nil}.  In
that case the first element of @var{start-list} defines the start
symbol and others are ignored.

The LALR(1) automaton is a vector of the form:

@code{[@var{actions gotos starts functions}]}

@table @var
@item actions
A state/token matrix telling the parser what to do at every state
based on the current look-ahead token.  That is shift, reduce, accept
or error.  See also @ref{Parsing}.

@item gotos
A state/nonterminal matrix telling the parser the next state to go to
after reducing with each rule.

@item starts
An alist which maps the allowed start symbols (nonterminals) to
lexical tokens that will be first shifted into the parser stack.

@item functions
An obarray of semantic action symbols.  A semantic action is actually
an Emacs Lisp function (lambda expression).
@end table
@end defun

@node Conflicts
@section Conflicts

Normally, a grammar should produce an automaton where at each state
the parser has only one action to do (@pxref{Parsing}).

@cindex ambiguous grammar
In certain cases, a grammar can produce an automaton where, at some
states, there are more than one action possible.  A such grammar is
@dfn{ambiguous}, and generated @dfn{conflicts}.

@cindex deterministic automaton
The parser can't be driven by an automaton which isn't completely
@dfn{deterministic}, that is which contains conflicts.  It is
necessary to resolve the conflicts to eliminate them.  Wisent resolves
conflicts like Bison does.

@cindex grammar conflicts
@cindex conflicts resolution
There are two sorts of conflicts:

@table @dfn
@cindex shift/reduce conflicts
@item shift/reduce conflicts
When either a shift or a reduction would be valid at the same state.

Such conflicts are resolved by choosing to shift, unless otherwise
directed by operator precedence declarations.
See @ref{Shift/Reduce , , , bison}, in the Bison manual for more
information.

@cindex reduce/reduce conflicts
@item reduce/reduce conflicts
That occurs if there are two or more rules that apply to the same
sequence of input.  This usually indicates a serious error in the
grammar.

Such conflicts are resolved by choosing to use the rule that appears
first in the grammar, but it is very risky to rely on this.  Every
reduce/reduce conflict must be studied and usually eliminated.  See
@ref{Reduce/Reduce , , , bison}, in the Bison manual for more
information.
@end table

@menu
* Grammar Debugging::           
* Understanding the automaton::  
@end menu

@node Grammar Debugging
@subsection Grammar debugging

@cindex grammar debugging
@cindex grammar verbose description
To help writing a new grammar, it is possible to tell
@code{wisent-compile-grammar} to produce a report containing verbose
descriptions of the grammar and parser (it is equivalent to the
@option{--verbose} option for Bison), by setting to non-@code{nil} this
variable:

@vindex wisent-verbose-flag
@defvar wisent-verbose-flag
non-@code{nil} means to report verbose information on generated parser.
@end defvar

The verbose report is printed in the temporary buffer
@code{*wisent-log*} when running interactively, or in file
@file{wisent.output} when running in batch mode.  Different
reports are separated from each other by a line like this:

@example
@group
*** Wisent @var{source-file} - 2002-06-27 17:33
@end group
@end example

where @var{source-file} is the name of the Emacs Lisp file from which
the grammar was read.  See @ref{Understanding the automaton}, for
details on the verbose report.

@vindex wisent-debug-flag
To help debugging the grammar compiler itself, set the variable
@code{wisent-debug-flag} to report the content of some internal data
structures.

@defvar wisent-debug-flag
non-@code{nil} means enable some debug stuff.
@end defvar

@node Understanding the automaton
@subsection Understanding the automaton

@cindex understanding the automaton
This section (took from the manual of Bison 1.49) describes how to use
the verbose report printed by @code{wisent-compile-grammar} to
understand the generated automaton, to tune or fix a grammar.

We will use the following example:

@example
@group
(let ((wisent-verbose-flag t)) ;; Print a verbose report!
  (wisent-compile-grammar
   '((NUM STR)                          ; %token NUM STR

     ((left ?+ ?-)                      ; %left '+' '-'; 
      (left ?*))                        ; %left '*'

     (exp                               ; exp:
      ((exp ?+ exp))                    ;    exp '+' exp
      ((exp ?- exp))                    ;  | exp '-' exp
      ((exp ?* exp))                    ;  | exp '*' exp
      ((exp ?/ exp))                    ;  | exp '/' exp
      ((NUM))                           ;  | NUM
      )                                 ;  ;

     (useless                           ; useless:
      ((STR))                           ;    STR
      )                                 ;  ;
     )
   'nil)                                ; no %start declarations
  )
@end group
@end example

When evaluating the above expression, grammar compilation first issues
the following two clear messages:

@example
@group
Grammar contains 1 useless nonterminals and 1 useless rules
Grammar contains 7 shift/reduce conflicts
@end group
@end example

The @samp{*wisent-log*} buffer details things!

The first section reports conflicts that were solved using precedence
and/or associativity:

@example
@group
Conflict in state 7 between rule 1 and token '+' resolved as reduce.
Conflict in state 7 between rule 1 and token '-' resolved as reduce.
Conflict in state 7 between rule 1 and token '*' resolved as shift.
Conflict in state 8 between rule 2 and token '+' resolved as reduce.
Conflict in state 8 between rule 2 and token '-' resolved as reduce.
Conflict in state 8 between rule 2 and token '*' resolved as shift.
Conflict in state 9 between rule 3 and token '+' resolved as reduce.
Conflict in state 9 between rule 3 and token '-' resolved as reduce.
Conflict in state 9 between rule 3 and token '*' resolved as reduce.
@end group
@end example

The next section reports useless tokens, nonterminal and rules (note
that useless tokens might be used by the scanner):

@example
@group
Useless nonterminals:

   useless


Terminals which are not used:

   STR


Useless rules:

#6     useless: STR;
@end group
@end example

The next section lists states that still have conflicts:

@example
@group
State 7 contains 1 shift/reduce conflict.
State 8 contains 1 shift/reduce conflict.
State 9 contains 1 shift/reduce conflict.
State 10 contains 4 shift/reduce conflicts.
@end group
@end example

The next section reproduces the grammar used:

@example
@group
Grammar

  Number, Rule
  1       exp -> exp '+' exp
  2       exp -> exp '-' exp
  3       exp -> exp '*' exp
  4       exp -> exp '/' exp
  5       exp -> NUM
@end group
@end example

And reports the uses of the symbols:

@example
@group
Terminals, with rules where they appear

$EOI (-1)
error (1)
NUM (2) 5
STR (3) 6
'+' (4) 1
'-' (5) 2
'*' (6) 3
'/' (7) 4


Nonterminals, with rules where they appear

exp (8)
    on left: 1 2 3 4 5, on right: 1 2 3 4
@end group
@end example

The report then details the automaton itself, describing each state
with it set of @dfn{items}, also known as @dfn{pointed rules}.  Each
item is a production rule together with a point (marked by @samp{.})
that the input cursor.

@example
@group
state 0

    NUM	shift, and go to state 1

    exp	go to state 2
@end group
@end example

State 0 corresponds to being at the very beginning of the parsing, in
the initial rule, right before the start symbol (@samp{exp}).  When
the parser returns to this state right after having reduced a rule
that produced an @samp{exp}, it jumps to state 2.  If there is no such
transition on a nonterminal symbol, and the lookahead is a @samp{NUM},
then this token is shifted on the parse stack, and the control flow
jumps to state 1.  Any other lookahead triggers a parse error.

In the state 1...

@example
@group
state 1

    exp  ->  NUM .   (rule 5)

    $default	reduce using rule 5 (exp)
@end group
@end example

the rule 5, @samp{exp: NUM;}, is completed.  Whatever the lookahead
(@samp{$default}), the parser will reduce it.  If it was coming from
state 0, then, after this reduction it will return to state 0, and
will jump to state 2 (@samp{exp: go to state 2}).

@example
@group
state 2

    exp  ->  exp . '+' exp   (rule 1)
    exp  ->  exp . '-' exp   (rule 2)
    exp  ->  exp . '*' exp   (rule 3)
    exp  ->  exp . '/' exp   (rule 4)

    $EOI	shift, and go to state 11
    '+'	shift, and go to state 3
    '-'	shift, and go to state 4
    '*'	shift, and go to state 5
    '/'	shift, and go to state 6
@end group
@end example

In state 2, the automaton can only shift a symbol.  For instance,
because of the item @samp{exp -> exp . '+' exp}, if the lookahead if
@samp{+}, it will be shifted on the parse stack, and the automaton
control will jump to state 3, corresponding to the item
@samp{exp -> exp . '+' exp}:

@example
@group
state 3

    exp  ->  exp '+' . exp   (rule 1)

    NUM	shift, and go to state 1

    exp	go to state 7
@end group
@end example

Since there is no default action, any other token than those listed
above will trigger a parse error.

The interpretation of states 4 to 6 is straightforward:

@example
@group
state 4

    exp  ->  exp '-' . exp   (rule 2)

    NUM	shift, and go to state 1

    exp	go to state 8



state 5

    exp  ->  exp '*' . exp   (rule 3)

    NUM	shift, and go to state 1

    exp	go to state 9



state 6

    exp  ->  exp '/' . exp   (rule 4)

    NUM	shift, and go to state 1

    exp	go to state 10
@end group
@end example

As was announced in beginning of the report, @samp{State 7 contains 1
shift/reduce conflict.}:

@example
@group
state 7

    exp  ->  exp . '+' exp   (rule 1)
    exp  ->  exp '+' exp .   (rule 1)
    exp  ->  exp . '-' exp   (rule 2)
    exp  ->  exp . '*' exp   (rule 3)
    exp  ->  exp . '/' exp   (rule 4)

    '*'	shift, and go to state 5
    '/'	shift, and go to state 6

    '/'	[reduce using rule 1 (exp)]
    $default	reduce using rule 1 (exp)
@end group
@end example

Indeed, there are two actions associated to the lookahead @samp{/}:
either shifting (and going to state 6), or reducing rule 1.  The
conflict means that either the grammar is ambiguous, or the parser
lacks information to make the right decision.  Indeed the grammar is
ambiguous, as, since we did not specify the precedence of @samp{/},
the sentence @samp{NUM + NUM / NUM} can be parsed as @samp{NUM + (NUM
/ NUM)}, which corresponds to shifting @samp{/}, or as @samp{(NUM +
NUM) / NUM}, which corresponds to reducing rule 1.

Because in LALR(1) parsing a single decision can be made, Wisent
arbitrarily chose to disable the reduction, see @ref{Conflicts}.
Discarded actions are reported in between square brackets.

Note that all the previous states had a single possible action: either
shifting the next token and going to the corresponding state, or
reducing a single rule.  In the other cases, i.e., when shifting
@emph{and} reducing is possible or when @emph{several} reductions are
possible, the lookahead is required to select the action.  State 7 is
one such state: if the lookahead is @samp{*} or @samp{/} then the
action is shifting, otherwise the action is reducing rule 1.  In other
words, the first two items, corresponding to rule 1, are not eligible
when the lookahead is @samp{*}, since we specified that @samp{*} has
higher precedence that @samp{+}.  More generally, some items are
eligible only with some set of possible lookaheads.

States 8 to 10 are similar:

@example
@group
state 8

    exp  ->  exp . '+' exp   (rule 1)
    exp  ->  exp . '-' exp   (rule 2)
    exp  ->  exp '-' exp .   (rule 2)
    exp  ->  exp . '*' exp   (rule 3)
    exp  ->  exp . '/' exp   (rule 4)

    '*'	shift, and go to state 5
    '/'	shift, and go to state 6

    '/'	[reduce using rule 2 (exp)]
    $default	reduce using rule 2 (exp)



state 9

    exp  ->  exp . '+' exp   (rule 1)
    exp  ->  exp . '-' exp   (rule 2)
    exp  ->  exp . '*' exp   (rule 3)
    exp  ->  exp '*' exp .   (rule 3)
    exp  ->  exp . '/' exp   (rule 4)

    '/'	shift, and go to state 6

    '/'	[reduce using rule 3 (exp)]
    $default	reduce using rule 3 (exp)



state 10

    exp  ->  exp . '+' exp   (rule 1)
    exp  ->  exp . '-' exp   (rule 2)
    exp  ->  exp . '*' exp   (rule 3)
    exp  ->  exp . '/' exp   (rule 4)
    exp  ->  exp '/' exp .   (rule 4)

    '+'	shift, and go to state 3
    '-'	shift, and go to state 4
    '*'	shift, and go to state 5
    '/'	shift, and go to state 6

    '+'	[reduce using rule 4 (exp)]
    '-'	[reduce using rule 4 (exp)]
    '*'	[reduce using rule 4 (exp)]
    '/'	[reduce using rule 4 (exp)]
    $default	reduce using rule 4 (exp)
@end group
@end example

Observe that state 10 contains conflicts due to the lack of precedence
of @samp{/} wrt @samp{+}, @samp{-}, and @samp{*}, but also because the
associativity of @samp{/} is not specified.

Finally, the state 11 (plus 12) is named the @dfn{final state}, or the
@dfn{accepting state}:

@example
@group
state 11

    $EOI	shift, and go to state 12



state 12

    $default	accept
@end group
@end example

The end of input is shifted @samp{$EOI shift,} and the parser exits
successfully (@samp{go to state 12}, that terminates).

@node Parsing
@chapter Parsing

@cindex bottom-up parser
@cindex shift-reduce parser
The Wisent's parser is what is called a @dfn{bottom-up} or
@dfn{shift-reduce} parser which repeatedly:

@table @dfn
@cindex shift
@item shift
That is pushes the value of the last lexical token read (the
look-ahead token) into a value stack, and reads a new one.

@cindex reduce
@item reduce
That is replaces a nonterminal by its semantic value.  The values of
the components which form the right hand side of a rule are popped
from the value stack and reduced by the semantic action of this rule.
The result is pushed back on top of value stack.
@end table

The parser will stop on:

@table @dfn
@cindex accept
@item accept
When all input has been successfully parsed.  The semantic value of
the start nonterminal is on top of the value stack.

@cindex syntax error
@item error
When a syntax error (an unexpected token in input) has been detected.
At this point the parser issues an error message and either stops or
calls a recovery routine to try to resume parsing.
@end table

@cindex table-driven parser
The above elementary actions are driven by the LALR(1) automaton built
by @code{wisent-compile-grammar} from a context-free grammar.

The Wisent's parser is entered by calling the function:

@findex wisent-parse
@defun wisent-parse automaton lexer &optional error start
Parse input using the automaton specified in @var{automaton}.

@table @var
@item automaton
Is an LALR(1) automaton generated by @code{wisent-compile-grammar}
(@pxref{Grammar}).

@item lexer
Is a function with no argument called by the parser to obtain the next
terminal (token) in input (@pxref{Writing a lexer}).

@item error
Is an optional reporting function called when a parse error occurs.
It receives a message string to report.  It defaults to the function
@code{error} (@pxref{Report errors}).

@item start
Specify the start symbol (nonterminal) used by the parser as its goal.
It defaults to the start symbol defined in the grammar
(@pxref{Grammar}).
@end table
@end defun

@menu
* Writing a lexer::             
* Actions goodies::             
* Report errors::               
* Error recovery::              
* Debugging actions::           
@end menu

@node Writing a lexer
@section What the parser must receive

It is important to understand that the parser does not parse
characters, but lexical tokens, and does not know anything about
characters in text streams!

@cindex lexical analysis
@cindex lexer
@cindex scanner
Reading input data to produce lexical tokens is performed by a lexer
(also called a scanner) in a lexical analysis step, before the syntax
analysis step performed by the parser.  The parser automatically calls
the lexer when it needs the next token to parse.

@cindex lexical tokens
A Wisent's lexer is an Emacs Lisp function with no argument.  It must
return a valid lexical token of the form:

@code{(@var{token-class value} [@var{start} . @var{end}])}

@table @var
@item token-class
Is a category of lexical token identifying a terminal as specified in
the grammar (@pxref{Grammar}).  It can be a symbol or a character
literal.

@item value
Is the value of the lexical token.  It can be of any valid Emacs Lisp
data type.

@item start
@itemx end
Are the optionals beginning and end positions of @var{value} in the
input stream.
@end table

@vindex wisent-eoi-term
When there are no more tokens to read the lexer must return the token
@code{(list wisent-eoi-term)} to each request.

@defvar wisent-eoi-term
Predefined constant, End-Of-Input terminal symbol.
@end defvar

@code{wisent-lex} is an example of a lexer that reads lexical tokens
produced by a Semantic lexer, and translates them into lexical tokens
suitable to the Wisent parser.  See also @ref{Wisent Lex}.

To call the lexer in a semantic action use the function
@code{wisent-lexer}.  See also @ref{Actions goodies}.

@node Actions goodies
@section Variables and macros useful in grammar actions.

@vindex wisent-input
@defvar wisent-input
The last token read.
The actual value of this variable is local to the parser.
@end defvar

@findex wisent-lexer
@defun wisent-lexer
Obtain the next terminal in input.
@end defun

@findex wisent-region
@defun wisent-region &rest positions
Return the start/end positions of the region including @var{positions}.
Each element of @var{positions} is a pair (@var{start-pos} .
@var{end-pos}) or @code{nil}.  The returned value is the pair
(@var{min-start-pos} . @var{max-end-pos}) or @code{nil} if no
@var{positions} are available.
@end defun

@node Report errors
@section The error reporting function

@cindex error reporting
When the parser encounters a syntax error it calls a user-defined
function.  It must be an Emacs Lisp function with one argument: a
string containing the message to report.

By default the parser uses the standard Emacs Lisp function
@code{error} to report error message and terminate.

At this point the variable @code{wisent-input} contains the unexpected
token as returned by the lexer.

The error reporting function can be called from a semantic action too
using the special macro @code{wisent-error}.  When called from a
semantic action entered by error recovery (@pxref{Error recovery}) the
value of the variable @code{wisent-recovering} is non-@code{nil}.

@node Error recovery
@section Error recovery

@cindex error recovery
The error recovery mechanism of the Wisent's parser conforms to the
one Bison uses.  See @ref{Error Recovery, , , bison}, in the
Bison manual for details.

@cindex error token
To recover from a syntax error you must write rules to recognize the
special token @code{error}.  This is a terminal symbol that is
automatically defined and reserved for error handling.

When the parser encounters a syntax error, it pops the state stack
until it finds a state that allows shifting the @code{error} token.
After it has been shifted, if the old look-ahead token is not
acceptable to be shifted next, the parser reads tokens and discards
them until it finds a token which is acceptable.

@cindex error recovery strategy
Strategies for error recovery depend on the choice of error rules in
the grammar.  A simple and useful strategy is simply to skip the rest
of the current statement if an error is detected:

@example
@group
(stmnt (( error ?; )) ;; on error, skip until ';' is read
       )
@end group
@end example

It is also useful to recover to the matching close-delimiter of an
opening-delimiter that has already been parsed:

@example
@group
(primary (( ?@{ expr  ?@} ))
         (( ?@{ error ?@} ))
         @dots{}
         )
@end group
@end example

@cindex error recovery actions
Note that error recovery rules may have actions, just as any other
rules can.  Here are some predefined hooks, variables, functions or
macros, useful in such actions:

@vindex wisent-nerrs
@defvar wisent-nerrs
The number of parse errors encountered so far.
@end defvar

@vindex wisent-recovering
@defvar wisent-recovering
non-@code{nil} when the parser is recovering.
The actual value of this variable is local to the parser.
@end defvar

@findex wisent-error
@defun wisent-error msg
Call the language specific error reporting function with message
@var{msg} (@pxref{Report errors}).

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@findex wisent-errok
@defun wisent-errok
Resume generating error messages immediately for subsequent syntax
errors.

The parser suppress error message for syntax errors that happens
shortly after the first, until three consecutive input tokens have
been successfully shifted.

Calling @code{wisent-errok} in an action, make error messages resume
immediately.  No error messages will be suppressed if you call it in
an error rule's action.

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@findex wisent-clearin
@defun wisent-clearin
Discard the current look-ahead token.
This will cause a new token to be read.

In an error rule's action the previous look-ahead token is reanalyzed
immediately.  @code{wisent-clearin} may be called to clear this token.

For example, suppose that on a parse error, an error handling routine
is called that advances the input stream to some point where parsing
should once again commence.  The next symbol returned by the lexical
scanner is probably correct.  The previous look-ahead token ought to
be discarded with @code{wisent-clearin}.

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@findex wisent-set-region
@defun wisent-set-region start end
Change the region of text matched by the current nonterminal.
@var{start} and @var{end} are respectively the beginning and end
positions of the region occupied by the group of components associated
to this nonterminal.  If @var{start} or @var{end} values are not a
valid positions the region is set to @code{nil}.

For example, the function @code{wisent-skip-block} described below
uses it to safely set the region to the start/end positions of the
current block of code.
@end defun

@vindex wisent-discarding-token-functions
@defvar wisent-discarding-token-functions
List of functions to be called when discarding a lexical token.@*
These functions receive the lexical token discarded.@*
When the parser encounters unexpected tokens, it can discards them,
based on what directed by error recovery rules.  Either when the
parser reads tokens until one is found that can be shifted, or when an
semantic action calls the function @code{wisent-skip-token} or
@code{wisent-skip-block}.@*
For language specific hooks, make sure you define this as a local
hook.

For example, in Semantic, this hook is set to the function
@code{wisent-collect-unmatched-syntax} to collect unmatched lexical
tokens (@pxref{Useful functions}).
@end defvar

@findex wisent-skip-token
@defun wisent-skip-token
Skip an invalid token and try to continue parsing.

It is implemented like this:

@lisp
@group
(defsubst wisent-skip-token ()
  "Skip an invalid token and try to continue parsing.
To be used in grammar recovery actions."
  (wisent-error (format "Skipping invalid '%s'" $nterm))
  ;; Clear the lookahead token
  (if (eq (car wisent-input) wisent-eoi-term)
      ;; does nothing at EOI to avoid infinite recovery loop
      nil
    (run-hook-with-args
     'wisent-discarding-token-functions wisent-input)
    (wisent-clearin)
    (wisent-errok)))
@end group
@end lisp
@end defun

@findex wisent-skip-block
@defun wisent-skip-block
Safely skip a block and try to continue parsing.
A block is data between an open-delimiter (syntax class @code{(}) and
a matching close-delimiter (syntax class @code{)}):

@example
@group
(a parenthesized block)
[a block between brackets]
@{a block between braces@}
@end group
@end example

The following example uses @code{wisent-skip-block} to safely skip a
block delimited by @samp{LBRACE} (@code{@{}) and @samp{RBRACE}
(@code{@}}) tokens:

@example
@group
(block ((LBRACE RBRACE))
       ((LBRACE error)
        (wisent-skip-block))
       )
@end group
@end example
@end defun

@node Debugging actions
@section Debugging semantic actions

@cindex semantic action symbols
Each semantic action is represented by a symbol interned in an obarray
that is part of the LALR automaton (@pxref{Compiling a grammar}).
@code{symbol-function} on a semantic action symbol return the semantic
action lambda expression.

A semantic action symbol name has the form
@var{nonterminal}:@var{index}, where @var{nonterminal} is the name of
the nonterminal symbol the action belongs to, and @var{index} is an
action sequence number within the scope of @var{nonterminal}.  For
example, this nonterminal definition:

@example
@group
input:
   line                     [@code{input:0}]
 | input line
   (format "%s %s" $1 $2)   [@code{input:1}]
 ;
@end group
@end example

Will produce two semantic actions, and associated symbols:

@table @code
@item input:0
A default action that returns $1.

@item input:1
That returns @code{(format "%s %s" $1 $2)}.
@end table

@cindex debugging semantic actions
Debugging uses the Lisp debugger to investigate what is happening
during execution of semantic actions.
Three commands are available to debug semantic actions.  They receive
two arguments:

@itemize @bullet
@item The automaton that contains the semantic action.

@item The semantic action symbol.
@end itemize

@findex wisent-debug-on-entry
@deffn Command wisent-debug-on-entry automaton function
Request @var{automaton}'s @var{function} to invoke debugger each time it is called.
@var{function} must be a semantic action symbol that exists in @var{automaton}.
@end deffn

@findex wisent-cancel-debug-on-entry
@deffn Command wisent-cancel-debug-on-entry automaton function
Undo effect of @code{wisent-debug-on-entry} on AUTOMATON's @var{function}.
@var{function} must be a semantic action symbol that exists in @var{automaton}.
@end deffn

@findex wisent-debug-show-entry
@deffn Command wisent-debug-show-entry automaton function
Show the source of @var{automaton}'s semantic action @var{function}.
@var{function} must be a semantic action symbol that exists in @var{automaton}.
@end deffn

@node Wisent Semantic
@chapter How to use Wisent with Semantic

@cindex semantic parse tree
This chapter presents how the Wisent's parser can be used to produce
@dfn{parse trees} for the Semantic tool set.

@cindex semantic token
@cindex semantic tags
A Semantic parse tree is a hierarchy of Emacs Lisp data structures,
called @dfn{Semantic tokens}, that describes a program in a way
independent of programming languages.  Semantic tokens can be seen as
@dfn{tags} that map program declarations, like functions, methods,
variables, data types, classes, includes, grammar rules, etc..

@menu
* WY grammar format::           
* WY Major Mode::               
* Grammar styles::              
* Wisent Lex::                  
@end menu

@node WY grammar format
@section WY grammar format

@cindex WY grammar format
A convenient way to use the Wisent parser with Semantic is to define
your grammar in @dfn{WY} form.  The WY grammar format is very close
to the format used to describe a Bison's grammar.  The main
differences are:

@itemize @bullet
@item
The use of Emacs Lisp syntax in place of C like syntax.

@item
Semantic specific Percent-keywords.
@end itemize

So, if you are already familiar with Bison and have some knowledge of
Emacs Lisp, writing WY grammars should be straightforward (@pxref{WY
Major Mode}).

@cindex WY grammar specification
A good way to describe the WY grammar format, and to see how it looks,
is to show its specification as a WY grammar:

@example
@group
%start grammar

;; Keywords
%token LEFT            "left"
%token NONASSOC        "nonassoc"
%token PREC            "prec"
%token PUT             "put"
%token RIGHT           "right"
%token START           "start"
%token TOKEN           "token"
%token LANGUAGEMODE    "languagemode"
%token OUTPUTFILE      "outputfile"
%token SETUPFUNCTION   "setupfunction"
%token KEYWORDTABLE    "keywordtable"
%token PARSETABLE      "parsetable"
%token TOKENTABLE      "tokentable"

;; Literals
%token <string>        STRING
%token <symbol>        SYMBOL
%token <number>        NUMBER
%token <char>          CHARACTER

;; Blocks
%token <semantic-list> PAREN_BLOCK "^("
%token <semantic-list> BRACE_BLOCK "^@{"

;; Parens
%token <open-paren>    LBRACE      "@{"
%token <close-paren>   RBRACE      "@}"

;; Punctuations
%token <punctuation>   COLON       ":"
%token <punctuation>   SEMI        ";"
%token <punctuation>   OR          "|"
%token <punctuation>   LT          "<"
%token <punctuation>   GT          ">"
%token <punctuation>   PERCENT     "%"

%%

grammar:
    PERCENT
  | code
  | declaration
  | nonterminal
  ;

code:
    PAREN_BLOCK
  | BRACE_BLOCK
  ;

declaration:
    languagemode_decl
  | outputfile_decl
  | setupfunction_decl
  | keywordtable_decl
  | parsetable_decl
  | tokentable_decl
  | token_decl
  | start_decl
  | left_decl
  | right_decl
  | nonassoc_decl
  | put_decl
  ;

languagemode_decl:
    LANGUAGEMODE symbols
  ;

outputfile_decl:
    OUTPUTFILE string_value
  ;

string_value:
    STRING
  ;

setupfunction_decl:
    SETUPFUNCTION any_symbol
  ;

keywordtable_decl:
    KEYWORDTABLE any_symbol
  ;

parsetable_decl:
    PARSETABLE any_symbol
  ;

tokentable_decl:
    TOKENTABLE any_symbol
  ;

token_decl:
    TOKEN token_type_opt any_symbol string_value
  | TOKEN token_type_opt symbols
  ;

token_type_opt:
  ;; EMPTY
  | token_type
  ;

token_type:
    LT any_symbol GT
  ;

start_decl:
    START symbols
  ;

left_decl:
    LEFT token_type_opt items
  ;

right_decl:
    RIGHT token_type_opt items
  ;

nonassoc_decl:
    NONASSOC token_type_opt items
  ;

put_decl:
    PUT any_symbol put_value
  | PUT any_symbol put_value_list
  | PUT put_name_list put_value
  | PUT put_name_list put_value_list
  ;

put_name_list:
    BRACE_BLOCK
  ;

put_names:
    LBRACE
  | RBRACE
  | any_symbol
  ;

put_value_list:
    BRACE_BLOCK
  ;

put_values:
    LBRACE
  | RBRACE
  | put_value
  ;

put_value:
    any_symbol any_value
  ;

any_value:
    any_symbol
  | STRING
  | NUMBER
  | PAREN_BLOCK
  ;

symbols:
    symbols any_symbol
  | any_symbol
  ;

nonterminal:
    any_symbol COLON rules SEMI
  ;

rules:
    rules OR rule
  | rule
  ;

rule:
 ;; empty
  | rule item
  | rule action
  | rule level
  ;

level:
    PERCENT PREC item
  ;

action:
    PAREN_BLOCK
  | BRACE_BLOCK
  ;

items:
    items item
  | item
  ;

item:
    any_symbol
  | CHARACTER
  ;

any_symbol:
    SYMBOL
  | LEFT
  | NONASSOC
  | PREC
  | PUT
  | RIGHT
  | START
  | TOKEN
  | LANGUAGEMODE
  | OUTPUTFILE
  | SETUPFUNCTION
  | KEYWORDTABLE
  | PARSETABLE
  | TOKENTABLE
  ;
@end group
@end example

Notice that comments are like Emacs Lisp ones but start with two
consecutive semicolons (@samp{;;}) instead of a single one.  Because
the single semicolon (@samp{;}) is the end of rule delimiter.

Also the WY grammar accepts single character literals as terminals in
C-like syntax (the @samp{CHARACTER} tokens in the above grammar).  For
example, the following are valid character literals:

@example
@group
'+', '-', ')', ';'    ;; punctuations
'\n', ' '             ;; whitespaces
@end group
@end example

See also @ref{Example}.

@menu
* Percent-keywords::            
@end menu

@node Percent-keywords
@subsection Percent-keywords

@table @code
@cindex %outputfile
@item %outputfile @var{file-name}
Required declaration that specifies the name of an Emacs Lisp source
file where to put Lisp code generated from the current grammar.
@var{file-name} must be a string.

@cindex %parsetable
@item %parsetable @var{variable-name}
Name of the variable set with the generated parser automaton.

@cindex %keywordtable
@item %keywordtable @var{variable-name}
Name of the variable set with the generated table of keywords.

@cindex %tokentable
@item %tokentable @var{variable-name}
Name of the variable set with the generated table of tokens.

@cindex %setupfunction
@item %setupfunction @var{function-name}
Name of the function where to put the generated setup code.

@cindex %languagemode
@item %languagemode @var{mode-name}@dots{}
Names of major modes where Semantic uses the Wisent's parser with this
grammar.

@cindex %start
@item %start @var{nonterminal}@dots{}
Declare the nonterminal start symbols.

@cindex %token
@item %token @var{terminal} @var{string-value}
Declare language keywords.  These terminal symbols are stored in the
variable declared by @code{%keywordtable}.

@item %token <@var{type}> @var{terminal} [@var{string-value}]
@itemx %token [<@var{type}>] @var{terminal}@dots{}
Declare terminal symbols that aren't keywords.  They are stored in
the variable declared by @code{%tokentable}.

@cindex %put
@item %put @{@var{terminal}@dots{}@} @{@var{property value}@dots{}@}
@itemx %put @var{terminal} @{@var{property value}@dots{}@}
@itemx %put @{@var{terminal}@dots{}@} @var{property value}
@itemx %put @var{terminal} @var{property value}
Give properties to tokens.

@cindex %left
@cindex %right
@cindex %nonassoc
@item %left @var{terminal}@dots{}
@itemx %right @var{terminal}@dots{}
@itemx %nonassoc @var{terminal}@dots{}
Assign associativity and precedence level to terminals.

@cindex %prec
@item %prec @var{terminal}
Assign @var{terminal} precedence level to current rule.  @code{%prec}
must be only used in a rule, like this:

@example
@group
exp:
  @dots{}
  | '-' exp %prec NEG
  @dots{}
  ;
@end group
@end example
@end table

@node WY Major Mode
@section WY Major Mode

@findex wy-mode
@findex wisent-wy-mode
A major mode (@code{wy-mode} or @code{wisent-wy-mode}) provides syntax
highlighting, automatic indentation, and useful commands to help
writing WY files with Emacs, and to automatically generate the grammar
in Lisp form with the declarations needed by Semantic.

An interesting feature is that @code{wy-mode} is Semantic-enabled and
the WY grammar is defined in a WY file: @file{semantic-grammar.wy}!

@findex semantic-grammar-update-outputfile
To generate the Emacs Lisp code that Semantic requires to parse
buffers use the command @code{semantic-grammar-update-outputfile}.

@deffn Command semantic-grammar-update-outputfile
Create or update grammar Lisp code in output file.

Use this command to automatically update or generate the file
specified in the @code{%outputfile} statement of the WY grammar in the
current buffer.

The variables named by the @code{%parsetable}, @code{%keywordtable}
and @code{%tokentable} declarations are updated with Lisp data
generated from the rules, the @code{%start}, @code{%left},
@code{%right}, @code{%nonassoc} and @code{%token}/@code{%put}
declarations found in the grammar (@pxref{Percent-keywords}).

The function named by the @code{%setupfunction} declaration is updated
with the Emacs Lisp open code (not in rule actions) found in the
grammar.  It can be Lisp function calls enclosed in @samp{(@dots{})}
or blocks (equivalent of @code{(progn @dots{})}) enclosed in
@samp{@{@dots{}@}}.  Also Semantic is configured to use the Wisent
parser instead of its default one.  Normally, the
@code{%setupfunction} should be installed in a major mode hook to
enable Semantic for this particular programming language.
@end deffn

@node Grammar styles
@section Grammar styles

@cindex grammar styles
Semantic parsing heavily depends on how you wrote the grammar.
There are mainly two styles to write a Wisent's grammar intended to be
used with the Semantic tool set: the @dfn{Iterative style} and the
@dfn{Bison style}.  Each one has pros and cons, and in certain cases
it can be worth a mix of the two styles!

@menu
* Iterative style::             
* Bison style::                 
* Mixed style::                 
* Start nonterminals::          
* Useful functions::            
@end menu

@node Iterative style
@subsection Iterative style

@cindex grammar iterative style
The @dfn{iterative style} is the preferred style to use with Semantic.
It relies on an iterative parser back-end mechanism which parses start
nonterminals one at a time and automagically skip unexpected lexical
tokens in input.

Compared to rule-based iterative functions (@pxref{Bison style}),
iterative parsers are better in that they can handle obscure errors
more cleanly.

@cindex semantic token, raw
@cindex raw semantic token
Each start nonterminal must produces a @dfn{raw semantic token} by
calling the function @code{wisent-token} with the appropriate
parameters.  See @ref{Start nonterminals}, for more informations.

@cindex semantic token, cooked
@cindex cooked semantic tokens
Then, each parsing iteration automatically translate raw tokens into
@dfn{cooked semantic tokens}, updating the raw token structure with
internal properties and buffer related data.

After parsing completed it results in a list of cooked tokens which
becomes the value of @code{semantic-toplevel-bovine-cache}.

@findex wisent-token
@defun wisent-token &rest return-val
Return a raw Semantic token including @var{return-val}.
Should be used in Semantic actions to build the bovine cache.
@end defun

The following example is a snippet of the iterative style Java grammar
provided in the Semantic distribution in the file
@file{wisent-java-tags.wy}.

@example
@group
%start formal_parameter_list
@dots{}

formal_parameter_list
  : PAREN_BLOCK
    (EXPANDFULL $1 formal_parameters)
  ;

formal_parameters
  : LPAREN
    ()
  | RPAREN
    ()
  | formal_parameter COMMA
  | formal_parameter RPAREN
  ;

formal_parameter
  : formal_parameter_modifier_opt type variable_declarator_id
    (wisent-token $3 'variable $2 nil
                  (ASSOC typemodifiers $1)
                  nil)
  ;
@end group
@end example

@findex EXPANDFULL
It shows the use of the @code{EXPANDFULL} built-in function to parse a
@samp{PAREN_BLOCK} which contains a @samp{formal_parameter_list}.
@code{EXPANDFULL} tells to recursively parse @samp{formal_parameters}
inside @samp{PAREN_BLOCK}.  The parser iterates until it digested all
available input data inside the @samp{PAREN_BLOCK}, trying to match
any of the @samp{formal_parameters} rules:

@itemize
@item @samp{LPAREN}

@item @samp{RPAREN}

@item @samp{formal_parameter COMMA}

@item @samp{formal_parameter RPAREN}
@end itemize

At each iteration it will return a @samp{formal_parameter} raw token,
or @code{nil} to skip unwanted (single @samp{LPAREN} or @samp{RPAREN}
for example) or unexpected input data.

@node Bison style
@subsection Bison style

@cindex grammar bison style
What we call the @dfn{Bison style} is the traditional style of Bison's
grammars.  Compared to iterative style, it is not straightforward to
use grammars written in Bison style in Semantic.  Mainly because such
grammars are designed to parse the whole input data in one pass, and
don't use the iterative parser back-end mechanism (@pxref{Iterative
style}).  With Bison style the parser is called once to parse the
grammar start nonterminal.

The following example is a snippet of the Bison style Java grammar
provided in the Semantic distribution in the file
@file{wisent-java.wy}.

@example
@group
%start formal_parameter_list
@dots{}

formal_parameter_list
  : formal_parameter_list COMMA formal_parameter
    (cons $3 $1)
  | formal_parameter
    (list $1)
  ;

formal_parameter
  : formal_parameter_modifier_opt type variable_declarator_id
    (wisent-cooked-token $3 'variable $2 nil
                         (ASSOC typemodifiers $1)
                         nil)
  ;
@end group
@end example

The first consequence is that syntax errors are not automatically
handled by Semantic.  Thus, it is necessary to explicitly handle them
at the grammar level, providing error recovery rules to skip
unexpected input data.

The second consequence is that the iterative parser can't do automatic
raw to cooked token translation, except for the start nonterminal
value.  It is necessary to explicitly return cooked semantic tokens
from concerned semantic actions by calling the function
@code{wisent-cooked-token} with the appropriate parameters.  See
@ref{Start nonterminals}, for incremental re-parse considerations.

@findex wisent-cooked-token
@defun wisent-cooked-token &rest return-val
Return a cooked Semantic token including @var{return-val}.
Should be used in Semantic actions to build the bovine cache.
@end defun

@node Mixed style
@subsection Mixed style

@cindex grammar mixed style
@example
@group
%start grammar
@dots{}

grammar:
  @dots{}
  | nonterminal
  ;
@dots{}

nonterminal:
    any_symbol COLON rules SEMI
    (wisent-token $1 'nonterminal nil $3 nil)
  | error SEMI
  ;

rules:
    lifo_rules
    (apply #'nconc (nreverse $1))
  ;

lifo_rules:
    lifo_rules OR rule
    (cons $3 $1)
  | rule
    (list $1)
  ;

rule:
    rhs
    @dots{}
    (wisent-cooked-token name 'rule type comps prec action nil)
  ;
@end group
@end example

This example shows how Iterative and Bison styles can be combined in
the same grammar to obtain a good compromise between grammar
complexity and an efficient parsing strategy in an interactive
environment.

@samp{nonterminal} is parsed using iterative style via the main
@samp{grammar} rule.  The semantic action calls @code{wisent-token} to
produce a Semantic raw token, automagically cooked by Semantic.

But @samp{rules} part is parsed in Bison style! Why?

Rule delimiters are the colon (@samp{:}), that follows the nonterminal
name, and a final semicolon (@samp{;}).  Unfortunately these
delimiters are not @code{open-paren}/@code{close-paren} type, and
Emacs syntactic analyzer can't easily isolate data between them to
produce a @code{semantic-list} token.  Consequently it is not possible
to use @code{EXPANDFULL} to iterate in @samp{RULES_PART}, like this:

@example
@group
nonterminal:
    any_symbol COLON rules SEMI
    (wisent-token $1 'nonterminal nil $3 nil)
  ;

rules:
    RULES_PART  ;; @strong{Map a @code{semantic-list} syntactic token}
    (EXPANDFULL $1 'rules)
  ;

rules:
    COLON
    ()
    OR
    ()
    SEMI
    ()
    rhs
    @dots{}
    (wisent-token name 'rule type comps prec action nil)
  ;
@end group
@end example

In such cases, when it is difficult for Emacs to obtain
@code{semantic-list} syntactic tokens, the best solution is to use
traditional Bison style with error recovery!

In some extreme cases, it can also be convenient to extend the lexer,
to deliver new syntactic tokens, to simplify the grammar.

@node Start nonterminals
@subsection Start nonterminals

@cindex start nonterminals
@cindex @code{reparse-symbol} property
When you write a grammar for Semantic, it is important to carefully
indicate the start nonterminals.  Each one defines an entry point in
the grammar, and after parsing its semantic value is returned to the
back-end iterative engine.  Consequently:

@strong{The semantic value of a start nonterminal must be a valid
Semantic token}.

Start nonterminals are declared by @code{%start} statements.  When
nothing is specified the first nonterminal that appears in the grammar
is the start nonterminal.

Generally, the following nonterminals must be declared as start
symbols:

@itemize @bullet
@item The main grammar entry point
@quotation
Of course!
@end quotation

@item nonterminals passed to @code{EXPAND}/@code{EXPANDFULL}
@quotation
These built-in functions recursively parse a part of input data, based
on rules of the given nonterminal.

For example, the following will parse @samp{PAREN_BLOCK} data using
the @samp{formal_parameters} rules:

@example
@group
formal_parameter_list
  : PAREN_BLOCK
    (EXPANDFULL $1 formal_parameters)
  ;
@end group
@end example

The semantic value of @samp{formal_parameters} becomes the value of
the @code{EXPANDFULL} expression.  It is a list of Semantic tokens
spliced in the parse tree.

To allow that the automaton must know that @samp{formal_parameters} is
a start symbol.  It must be declared:

@example
@group
%start formal_parameters
@end group
@end example
@end quotation
@end itemize

@cindex incremental re-parse
@cindex reparse-symbol
The @code{EXPANDFULL} built-in function has a side effect it is
important to know, related to the incremental re-parse mechanism of
Semantic.  The nonterminal symbol parameter passed to
@code{EXPANDFULL} also becomes the @code{reparse-symbol} property of
the Semantic tokens returned by the @code{EXPANDFULL} expression.

When buffer's data mapped by one of these tokens is modified, Semantic
schedules an incremental re-parse of that data, using the token's
@code{reparse-symbol} property as start nonterminal.  So the rules
associated to this start symbol must be carefully reviewed to ensure
that partial re-parse will work!

Things are a little bit different when the grammar is written in
Bison style and uses the function @code{wisent-cooked-token} to directly
produce cooked Semantic tokens.  In a such case, the @code{reparse-symbol}
property is set with the nonterminal symbol the current rule belongs
to.

For example,

@example
@group
rule:
    rhs
    @dots{}
    (wisent-cooked-token name 'rule type comps prec action nil)
  ;
@end group
@end example

Set the @code{reparse-symbol} property of the cooked token to
@samp{rule}.  A important consequence is that:

@strong{Every nonterminal having any rule that calls
@code{wisent-cooked-token} in a semantic action, should be declared as
a start symbol!}

@node Useful functions
@subsection Useful functions

Here is a description of some predefined functions it might be useful
to know when writing new code to use Wisent in Semantic:

@findex wisent-collect-unmatched-syntax
@defun wisent-collect-unmatched-syntax input
Add @var{input} lexical token to the cache of unmatched tokens, in
variable @code{semantic-unmatched-syntax-cache}.

See implementation of the function @code{wisent-skip-token} in
@ref{Error recovery}, for an example of use.
@end defun

@node Wisent Lex
@section The Wisent Lex lexer

@findex semantic-lex
The lexical analysis step of Semantic is performed by the general
function @code{semantic-lex}, that produces tokens of the form:

@cindex semantic-lex tokens
@example
@group
@code{(@var{semantic-lex-token-class start} . @var{end})}
@end group
@end example

@table @var
@item semantic-lex-token-class
Is a symbol that identifies a category of tokens, like @code{symbol},
@code{string} or @code{number}.  See the documentation of variable
@code{semantic-lex-tokens} for a list of common token categories that
@code{semantic-lex} returns.

@item start
@itemx end
Are the bounds of the token in the current buffer.
@end table
 
Unfortunately, the Wisent's parser requires that lexical tokens have a
different form (@pxref{Writing a lexer}):

@example
@group
@code{(@var{token-class value} [@var{start} . @var{end}])}
@end group
@end example

@cindex token mapping
@findex wisent-lex
The Wisent lexer used in Semantic: @code{wisent-lex}, is just a
convenient function that translates lexical tokens as produced by
@code{semantic-lex} into an equivalent Wisent form.  Mapping is
straightforward:

@example
@group
(@var{semantic-lex-token-class start} . @var{end})
     @result{} (@var{semantic-lex-token-class value start} . @var{end})
@end group
@end example

@var{value} is the @code{buffer-substring} from @var{start} to
@var{end}.

@defun wisent-lex
Return the next available lexical token in Wisent's form.

@vindex wisent-lex-istream
The variable @code{wisent-lex-istream} contains the list of lexical
tokens produced by @code{semantic-lex}.  Pop the next token available
and convert it to a form suitable for the Wisent's parser.
@end defun

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi

@node Index
@unnumbered Index

@printindex fn

@c Print the tables of contents
@summarycontents
@contents
@c That's all
@bye

@c  LocalWords:  Wisent automagically wisent
