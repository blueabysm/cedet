\input texinfo   @c -*-texinfo-*-
@c
@c $Id: wisent.texi,v 1.4 2002-02-05 20:03:22 ponced Exp $
@c
@setfilename wisent.info
@settitle The Bison-compatible Parser Generator for Emacs

@ifinfo
@format
START-INFO-DIR-ENTRY
* Wisent: (wisent).       The Bison-compatible Parser Generator for Emacs
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@paragraphindent 0
@exampleindent   3

@titlepage
@sp 10
@center @titlefont{Wisent}
@vskip 0pt plus 1 fill
Copyright @copyright{} 2001, 2002 David Ponce
@end titlepage

@ifnottex
@node Top, Overview, (dir), (dir)
@comment  node-name,  next,  previous,  up
@top GNU Bison for Emacs
@end ifnottex

This manual documents Wisent, the Bison-compatible Parser Generator
for Emacs.

@menu
* Overview::                    Overview.
* Grammar::                     Grammar.
* Grammar format::              Grammar format.
* Conflicts::                   Conflicts.
* Example::                     Example.
* Parsing::                     Parsing.
* Index::                       Index.
@end menu

@node Overview, Grammar, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Overview

Wisent (the European Bison ;-) is an Elisp implementation of the GNU
Compiler Compiler Bison.

It can generate compilers compatible with the Semantic tool set
@inforef{Top, , semantic.info}.

The Elisp code is a port of the C code of GNU Bison 1.28 & 1.31.

Thus Wisent benefits of the main Bison's features.

@itemize @bullet
@item 
It uses a fast but not so space-efficient encoding for the parse
tables, described in Corbett's PhD thesis from Berkeley:

@quotation
@cite{Static Semantics in Compiler Error Recovery}@*
June 1985, Report No. UCB/CSD 85/251.
@end quotation

@item 
For generating the lookahead sets, Wisent uses the well-known
technique of F. DeRemer and A. Pennello they described in:

@quotation
@cite{Efficient Construction of LALR(1) Lookahead Sets}@*
October 1982, ACM TOPLS Vol 4 No 4.
@end quotation

@item 
Wisent resolves shift/reduce conflicts using operator precedence and
associativity @xref{Conflicts}.

@item 
Parser error recovery is accomplished using rules which match the
special token @code{error}.
@end itemize

So, for more details on the basic concepts for understanding Wisent,
read the Bison manual ;) @inforef{Top, , bison.info}.

@node Grammar, Parsing, Overview, Top
@comment  node-name,  next,  previous,  up
@chapter Grammar

In order for Wisent to parse a language, it must be described by a
Context Free Grammar (@acronym{CFG}).  This grammar is compiled using
the function @code{wisent-compile-grammar}.  This produces the
automaton (a set of tables) needed by the parser.

The formal grammar is formulated using terminal and nonterminal
symbols which are represented in Wisent as Elisp symbols.

Terminal symbols (also known as a @dfn{token}) represent the lexical
elements of the language like numbers, strings, etc..

For example @code{PLUS} can represent the operator @code{+}.

Nonterminal symbols are described by rules of the form:

@example
RESULT: COMPONENTS...
      ;
@end example

where @var{RESULT} is the nonterminal symbol that this rule describes
and @var{COMPONENTS} are various terminal and nonterminal symbols that
are put together by this rule.

For example,

@example
exp: exp PLUS exp
   ;
@end example

says that two groupings of type @code{exp}, with a @code{PLUS} token in
between, can be combined into a larger grouping of type @code{exp}.
 
By convention, a nonterminal symbol should be in lower case, such as
@code{expr}, @code{stmt} or @code{declaration}.  Terminal symbols
should be upper case to distinguish them from nonterminals: for
example, @code{INTEGER}, @code{IDENTIFIER}, @code{IF} or
@code{RETURN}.  A terminal symbol represents a particular keyword in
the language and is conventionally the same as that keyword converted
to upper case.  The terminal symbol @code{error} is reserved for error
recovery.

@defun wisent-compile-grammar grammar &optional start-list
Compile @var{GRAMMAR} (@pxref{Grammar format}) and return the tables
needed by the parser.

Optional argument @var{start-list} is list of extra start symbols
(nonterminals).  The first nonterminal defined in the grammar is
always the default start symbol.

Return an @dfn{LALR} automaton of the form:

@lisp
[ACTIONS GOTOS FUNCTIONS TRANSLATE STARTS]
@end lisp

@table @var
@item actions
A state/token matrix telling the parser what to do at every state
based on the current lookahead token.  That is shift, reduce, accept
or error @xref{Parsing}.
@item gotos
a state/nonterminal matrix telling the parser the next state to go to
after reducing with each rule.
@item functions
A vector of semantic actions.  A semantic action is actually an Elisp
function (lambda expression).  By default these functions are
byte-compiled to achieve best performance.
@item translate
An alist which maps tokens returned by lexical analysis
into item numbers used internally.
@item starts
An alist which maps the allowed start symbols (nonterminal)
to tokens that will be first shifted into the parser stack.
@end table
@end defun

@menu
* Grammar format::              
* Conflicts::                   
* Example::                     
@end menu

@node Grammar format, Conflicts, Grammar, Grammar
@comment  node-name,  next,  previous,  up
@section Grammar format

This is a list @code{(TERMINALS ASSOCS . NON-TERMINALS)} where:

>>> From an implementation standpoint, would it make sense for
    TERMINALS and ASSOCS to be in separate variables defined earlier
    in the language set up file, and passed down the the compiler?
 
    My thinking is that perhaps the ASSOCS, at least, might be useful
    to reference in that precidence reminders could be displayed via
    eldoc or overlays while editing, and easier access might be nice.

    It could also be possible to have incremental rebuilds if
    needed.  Does this make sense?

<<< TERMINALS and ASSOCS values are actually part of the grammar
    specification!  The LALR tables produced by the parser generator
    completely depend on the actual value of these fields.  That is if
    you change something in TERMINALS and/or in ASSOCS the LALR tables
    won't be the same.  So I think it is better to keep them in the
    grammar definition as they currently are.

>>> Ok.  Since I was only concerned with referencing these fields, a
    simple API can be devised later to query the state to provide
    runtime editing help if desired.

@table @var
@item terminals
The list of terminal symbols used in the grammar.

@item assocs
Specify the associativity of terminals like do the Bison
@code{%nonassoc}, @code{%left} and @code{%right} statements.  It is
nil or a list of elements of the form @code{(ASSOC-TYPE .
ASSOC-TERMS)} where @var{ASSOC-TYPE} is one of @code{'nonassoc},
@code{'left} or @code{'right}, and @var{TERMS} is a list of terminal
symbols which must be declared in @var{TERMINALS}.
@item non-terminals
The list of non terminal definitions.  Each definition has the form
@code{(NONTERM . PRODS)} where @var{NONTERM} is the non terminal
symbol and @var{PRODS} the list of productions associated to this non
terminal.  Each element of @var{PRODS} has the form:

@code{(ITEMS [PRECEDENCE] [ACTION])} where:

@table @var
@item items
Is a list of terminal and/or non terminal symbols to match.  Or nil
for an empty match.
@item precedence
Is an optional vector of one element: a terminal symbol.  The rule
will be given the precedence level of this terminal symbol.  By
default the rule precedence is the one of the last terminal symbol in
it.  Only terminals declared in @var{ASSOCS} have a precedence level.

>>> If precidence is defined in the ASSOC table and here, what is the
    precidence table needed for?

<<< The ASSOCS table defines associativity and an implicit precedence
    level for given terminals.  PRECEDENCE here explicitly defines the
    precedence level of the rule (as the precedence level of a
    terminal specified in ASSOCS).

@item action
Is one optional Elisp expression: the action to do when the rule is
matched.  As in Bison, actions accept @code{$N} placeholders.  Each
@code{$N} placeholder is actually a variable local to the semantic
action.  It will receive the value of Nth element of @var{ITEMS} which
can be of any Lisp data type.  The first element is @code{$1}, the
second one @code{$2}, etc..  Unlike Bison, Wisent does not allow the
use of @code{$N} placeholders with N <= 0.

Also the special variable @code{$region} contains the start/end
positions of text matched by the rule, as a pair @code{(START-POS .
END-POS)}.  @code{$region} is nil when used in an empty match rule.
Actions can use @code{wisent-set-region} to modify the region, this
could be useful in actions used to recover from syntax errors.

>>> Perhaps $start and $end, and even $1region, or $region1 would
    also be useful.  I sometimes find myself writing special rules,
    just to get the region of one part of the rule.

<<< $start and $end can be easily obtained using respectively
    (car $region) and (cdr $region).  But I agree with you that
    having a $regionn for each $n is a good idea!

Finally the special symbol @code{$nterm} contain the nonterminal symbol
the action belongs to.  It could be useful to improve error reporting
or debugging.

If you don't specify an action for a rule, Wisent (like Bison)
supplies a default: @code{$1}.  Thus, the value of the first symbol in
the rule becomes the value of the whole rule.  The default action for
an empty match returns nil.
@end table
@end table

@node Conflicts, Example, Grammar format, Grammar
@comment  node-name,  next,  previous,  up
@section Conflicts

Wisent resolves conflicts in grammars the same way Bison does.

It resolves a reduce/reduce conflict by choosing to use the rule that
appears first in the grammar.

It resolves shift/reduce conflicts by choosing to shift, unless
otherwise directed by operator precedence declarations (see
@var{ASSOCS} and @var{NON-TERMINALS} in @pxref{Grammar format}).

@node Example,  , Conflicts, Grammar
@comment  node-name,  next,  previous,  up
@section Example

Here is an example of a Bison like grammar to parse simple infix
arithmetic expressions.  It is explained more fully in the Bison
manual: @inforef{Infix Calc, Examples, bison.info}.

@example
%token NUM
%token NL
%token EQ
%token PLUS
%token MINUS
%token NEG
%token MULT
%token DIV
%token EXP
%token LPAREN
%token RPAREN

%nonassoc EQ
%left     PLUS MINUS
%left     MULT DIV
%left     NEG
%right    EXP

input:
    /* empty */
  | input line
  ;

line:
    NL
  | exp NL
  ;

exp:
    NUM
  | exp EQ exp
  | exp PLUS exp
  | exp MINUS exp
  | exp MULT exp
  | exp DIV exp
  | MINUS exp %prec NEG
  | exp EXP exp
  | LPAREN exp RPAREN
  ;
@end example

The following is the corresponding form accepted by Wisent:

@lisp
((NUM NL EQ PLUS MINUS NEG MULT DIV EXP LPAREN RPAREN)
 ((nonassoc EQ)
  (left PLUS MINUS)
  (left MULT DIV)
  (left NEG)
  (right EXP))
 (input
  (nil)
  ((input line)))
 (line
  ((NL))
  ((exp NL)))
 (exp
  ((NUM))
  ((exp EQ exp))
  ((exp PLUS exp))
  ((exp MINUS exp))
  ((exp MULT exp))
  ((exp DIV exp))
  ((MINUS exp) [NEG])
  ((exp EXP exp))
  ((LPAREN exp RPAREN))))
@end lisp

@node Parsing, Index, Grammar, Top
@comment  node-name,  next,  previous,  up
@chapter Parsing

The parser used by Wisent is a bottom-up @acronym{LR} parser driven by
the automaton produced by @code{wisent-compile-grammar} from a
@acronym{CFG} grammar (@pxref{Grammar}).

An @acronym{LR} parser, also called a @dfn{shift-reduce} parser, is
based on states stored in a stack and on four elementary operations
performed at every state:

@table @dfn
@item shift
This operation reads the next lexical token available in input and
pushes it into the stack.
@item reduce
This operation replaces a nonterminal by its semantic value.  The
nonterminal component values are popped from the stack and reduced by
the semantic action associated to this nonterminal.  The result is
pushed back on top of stack.
@item accept
This operation stops the parser which has successfully processed all
input tokens.  The semantic value of the start nonterminal is on top
of stack. 
@item error
This operation interrupts parsing because of a syntax error (an
unexpected token in input).  At this point the parser can call a
recovery routine and try to resume or simply issue an error message
and stop.
@end table

@defun wisent-parse automaton lexer &optional error start
Parse input using the automaton specified in @var{automaton}.

@table @var
@item automaton
Is an LALR automaton (a set of tables) generated by
@code{wisent-compile-grammar}. @xref{Grammar}.
@item lexer
Is a function with no argument called by the parser to obtain the next
terminal (token) in input. @xref{Writing a Lexer}.
@item error
Is an optional reporting function called when a parse error occurs.
It receives a message string to report.  It defaults to the function
@code{error}. @xref{Report errors}.
@item start
Specify the start symbol (nonterminal) used by the parser as its goal.
It defaults to the first nonterminal defined in the
grammar. @xref{Grammar}.
@end table
@end defun

@menu
* Writing a Lexer::             What the parser must receive.
* Report errors::               The error reporting function.
* Writing Actions::             Variables and macros useful in grammar actions.
@end menu

@node Writing a Lexer, Report errors, Parsing, Parsing
@comment  node-name,  next,  previous,  up
@subsection What the parser must receive

It is important to understand that the parser does not parse
characters, but lexical tokens, and does not know anything about
characters and streams!

Reading input data to produce lexical tokens is performed by a lexer
(also called a scanner) in a lexical analysis step, before the syntax
analysis step performed by the parser.  The parser automatically calls
the lexer when it needs the next token to parse.

A Wisent's lexer is an Elisp function with no argument.  It must
return a valid lexical token of the form:

@lisp
(SYMBOL VALUE [START . END])
@end lisp

@table @var
@item symbol
Is the unique symbol identifying a terminal as specified in the
grammar (@pxref{Grammar}).
@item value
Is the actual value of @var{symbol}.  It can be of any valid Elisp
data type.
@item start
@itemx end
Are the optionals beginning and end positions of @var{value} in the
input stream.
@end table

When there are no more tokens to read the lexer must return the token
@code{(list 'wisent-eoi-term)} to each request. 

It is possible to call the lexer from a grammar's semantic action
using the macro @code{wisent-lexer}.

>>> Does this eat the token, or just fetch it, and leave it on the
    stack of things still to parse?  The existing of `wisent-clearin'
    indicates that the lookahead token is not modified.

@node Report errors, Writing Actions, Writing a Lexer, Parsing
@comment  node-name,  next,  previous,  up
@subsection The error reporting function

When the parser encounters a syntax error it calls a user-defined
function.  It must be an Elisp function with one argument: a string
containing the message to report.

By default the parser uses the standard Elisp function @code{error} to
report error message and terminate.

At this point the variable @code{wisent-input} contains the unexpected
token as returned by the lexer.

The error reporting function can be called from a semantic action too
using the special macro @code{wisent-error}.  When called from a
semantic action entered by error recovery the value of the variable
@code{wisent-recovering} is non-nil.

>>> Is it possible to ignore this token and move onto the next.
    For example, default behavior might be to allow 1 or 2 terminals
    of slop in the middle of a match before throwing a hard error.
    This would make the parser more robust to autoparsing during
    typing.  This is somewhat suggested with `wisent-nerrs'.
    The default would remain `error', but the semantic tool set may
    try to install different error handlers depending on when
    it chooses to parse the file.  `wisent-clearin' and a couple other
    skip functions alludes to this possibility.  Describing this in
    detail here would be great.

@node Writing Actions,  , Report errors, Parsing
@comment  node-name,  next,  previous,  up
@subsection Variables and macros useful in grammar actions.

@defvar wisent-nerrs
The number of parse errors encountered so far.
@end defvar

@defvar wisent-input
The last token read.
The actual value of this variable is local to the parser.
@end defvar

@defun wisent-lexer
Obtain the next terminal in input.
@end defun

@defvar wisent-recovering
Non-@code{nil} when the parser is recovering.
The actual value of this variable is local to the parser.
@end defvar

@defun wisent-error msg
Call the language specific error reporting function with message @var{MSG}.

>>> Perhaps specify a use here.

@end defun

@defun wisent-errok
Resume generating error messages immediately for subsequent syntax errors.
This is useful primarily in error rules.
@end defun

@defun wisent-clearin
Discard the current look-ahead token.
This will cause a new token to be read.  This is useful primarily in
error rules.
@end defun

@defun wisent-region &rest positions
Return the start/end positions of the region including @var{POSITIONS}.
Each element of @var{POSITIONS} is a pair (@var{START-POS} .
@var{END-POS}) or nil.  The returned value is the pair
(@var{MIN-START-POS} . @var{MAX-END-POS}) or @code{nil} if no
@var{POSITIONS} are available.
@end defun

>>> Based on earlier text, allowing POSITIONS to be $1 $2 etc in the
    bnf file would be handy too.

@defun wisent-set-region start end
Change the region of text matched by the current nonterminal.
@var{START} and @var{END} are respectively the beginning and end
positions of the region.  If @var{START} or @var{END} values are not a
valid positions the region is set to nil.

>>> Examples of using this would be nice, though it strikes me as
    being a feature of the lexer.

<<< `wisent-skip-block' is an example of use.  See below.

@end defun

@defun wisent-skip-token
Skip an invalid token and try to continue parsing.
To be used in grammar recovery actions.
@end defun

@defun wisent-skip-block
Safely skip a parenthesized block and try to continue parsing.
To be used in grammar recovery actions.

>>> Are tokens the same as blocks? 

<<< No.  A block contains the lexical tokens expanded from the
    corresponding high level semantic-list token.  This function skips
    the current block and use `wisent-set-region' to set $region to
    the block start/end positions.  That is the block is just
    returned as a whole token without parsing its content.  Combined
    with error recovery this is an equivalent to the EXPANDFULL
    feature when all low level lexical tokens are read.  That is
    `semantic-flex-depth' is nil instead of 0.
    
    wisent-java.bnf is an example of use of this feature.  Input
    source is parsed in one pass (no semantic-list) and errors are
    handled in grammar semantic actions.

    As opposite wisent-java-tags.bnf specifies a multi-pass recursive
    parser like the default LL one.  Errors are handled outside of the
    grammar via the EXPANDFULL feature.

>>> You may want to add a simple definition of BLOCK here.
@end defun

>> Do the above contribute to the wisent-nerrs variable?
<< Not directly.  wisent-nerrs is incremented each time a parse error
   occurs.  If wisent-skip-... functions are mainly useful in error
   recovery semantic actions they can be used in ``normal'' semantic
   actions.

>> Perhaps this should be broken into three sections.  One for a
   simple action writing and examples, then one for parser state,
   and a third for error recovery.
<< Good idea and more work to do ;-)

>> An error recovery node, in the future, could be quite valuable
   in rebuilding token lists in a partially re-written buffer, and
   deserves some development time for semantic 2.0.
<< Ditto ;-)

@node Index,  , Parsing, Top
@comment  node-name,  next,  previous,  up
@unnumbered Index

@printindex cp

@contents
@bye
