\input texinfo   @c -*-texinfo-*-
@c
@c $Id: wisent.texi,v 1.7 2002-06-21 22:35:19 ponced Exp $
@c
@setfilename wisent.info
@settitle The Bison-compatible Parser Generator for Emacs

@ifinfo
@format
START-INFO-DIR-ENTRY
* Wisent: (wisent).       The Bison-compatible Parser Generator for Emacs
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@paragraphindent 0
@exampleindent   3

@titlepage
@sp 10
@center @titlefont{Wisent}
@vskip 0pt plus 1 fill
Copyright @copyright{} 2001, 2002 David Ponce
@end titlepage

@ifnottex
@node Top, Overview, (dir), (dir)
@comment  node-name,  next,  previous,  up
@top GNU Bison for Emacs
@end ifnottex

This manual documents Wisent, the Bison-compatible Parser Generator
for Emacs.

@menu
* Overview::                    
* Grammar::                     
* Parsing::                     
* Wisent Bovine::               
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Grammar

* Grammar format::              
* Conflicts::                   
* Example::                     

Parsing

* Writing a lexer::
* Writing semantic actions::    
* Report errors::               
* Error recovery::              

How to use Wisent with Semantic

* WY grammar format::           
* Grammar styles::              
* Wisent Flex::                 

Grammar styles

* Bovine style::                
* Bison style::                 

Bovine style

* Top level nonterminals::      
* Bovine style example::        

Bison style

* Bison style example::         

@end detailmenu
@end menu

@node Overview, Grammar, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Overview

Wisent (the European Bison ;-) is an Elisp implementation of the GNU
Compiler Compiler Bison.

It can generate compilers compatible with the Semantic tool set
@inforef{Top, , semantic.info}.

The Elisp code is a port of the C code of GNU Bison 1.28 & 1.31.

Thus Wisent benefits of the main Bison's features.

@itemize @bullet
@item 
It uses a fast but not so space-efficient encoding for the parse
tables, described in Corbett's PhD thesis from Berkeley:

@quotation
@cite{Static Semantics in Compiler Error Recovery}@*
June 1985, Report No. UCB/CSD 85/251.
@end quotation

@item 
For generating the lookahead sets, Wisent uses the well-known
technique of F. DeRemer and A. Pennello they described in:

@quotation
@cite{Efficient Construction of LALR(1) Lookahead Sets}@*
October 1982, ACM TOPLS Vol 4 No 4.
@end quotation

@item 
Wisent resolves shift/reduce conflicts using operator precedence and
associativity @xref{Conflicts}.

@item 
Parser error recovery is accomplished using rules which match the
special token @code{error}.
@end itemize

For more details on the basic concepts for understanding Wisent, it is
worthwhile to read the Bison manual ;) @inforef{Top, , bison.info}.
It should be available at
@url{http://www.gnu.org/manual/bison/index.html}.

Nevertheless there are some fundamental differences between Bison and
Wisent.

@itemize
Wisent is intended to be used in Emacs.  It reads and produces Emacs
Lisp data structures.  All the additional code used in grammars is
Emacs Lisp code.
@item
Contrary to Bison, Wisent does not generate a parser which combines
Emacs Lisp code and grammar constructs.  They exist separately.
Wisent reads the grammar from a Lisp data structure and then generates
grammar constructs as tables.  Afterward, the derived tables can be
included and byte-compiled in separate Emacs Lisp files, and be used
at a later time by the Wisent's parser engine.
@item
Wisent allows multiple start nonterminals and allows a call to the
parsing function to be made for a particular start nonterminal.  For
example, this is particularly useful to parse a region of an Emacs
buffer.  Semantic heavily depends on the availability of this feature.
@end itemize

@node Grammar, Parsing, Overview, Top
@comment  node-name,  next,  previous,  up
@chapter Grammar

In order for Wisent to parse a language, it must be described by a
@dfn{context-free grammar}.  That is a grammar specified as rules that
can be applied regardless of context @inforef{Language and Grammar, ,
bison.info}.

The formal grammar is formulated using @dfn{terminal} and
@dfn{nonterminal} items.  Terminals can be Emacs Lisp symbols or
characters, and nonterminals are symbols only.

Terminals (also known as @dfn{tokens}) represent the lexical
elements of the language like numbers, strings, etc..

For example @code{PLUS} can represent the operator @code{+}.

Nonterminal symbols are described by rules of the form:

@example
RESULT: COMPONENTS...
      ;
@end example

where @var{RESULT} is the nonterminal symbol that this rule describes
and @var{COMPONENTS} are various terminal and nonterminal items that
are put together by this rule.

For example,

@example
exp: exp PLUS exp
   ;
@end example

says that two groupings of type @code{exp}, with a @code{PLUS} token in
between, can be combinent ed into a larger grouping of type @code{exp}.
 
By convention, a nonterminal symbol should be in lower case, such as
@code{expr}, @code{stmt} or @code{declaration}.  Terminal symbols
should be upper case to distinguish them from nonterminals: for
example, @code{INTEGER}, @code{IDENTIFIER}, @code{IF} or
@code{RETURN}.  A terminal symbol represents a particular keyword in
the language and is conventionally the same as that keyword converted
to upper case.  The terminal symbol @code{error} is reserved for error
recovery.

To be usable by the parser, a context-free grammar must be translated
into an @dfn{automaton}, that is a set of tables used to drive the
parser.  Like Bison, Wisent translates (compiles) context-free
grammars into @dfn{LALR(1)} automatons.

A grammar is LALR(1) if it is possible to tell how to parse any
portion of an input string with just a single token of look-ahead: the
@dfn{look-ahead token} (@inforef{Language and Grammar, , bison.info}).

To compile a grammar use the function:

@defun wisent-compile-grammar grammar &optional start-list
Compile @var{GRAMMAR} (@pxref{Grammar format}) and return an LALR(1)
automaton.

Optional argument @var{start-list} is a list of start symbols
(nonterminals).  If @code{nil} the first nonterminal defined in the
grammar is the default start symbol.  If @var{start-list} contains
only one element, it defines the start symbol.  If @var{start-list}
contains more than one element, all are defined as potential start
symbols, unless @code{wisent-single-start-flag} is non-@code{nil}.  In
that case the first element of @var{start-list} defines the start
symbol and others are ignored.

The LALR(1) automaton is a vector of the form:

@lisp
[ACTIONS GOTOS FUNCTIONS TRANSLATE STARTS]
@end lisp

@table @var
@item actions
A state/token matrix telling the parser what to do at every state
based on the current look-ahead token.  That is shift, reduce, accept
or error @xref{Parsing}.
@item gotos
A state/nonterminal matrix telling the parser the next state to go to
after reducing with each rule.
@item functions
A vector of semantic actions.  A semantic action is actually an Emacs
Lisp function (lambda expression).  By default these functions are
byte-compiled to achieve best performance.
@item translate
An alist which maps tokens returned by lexical analysis into item
numbers used internally.
@item starts
An alist which maps the allowed start symbols (nonterminals) to
lexical tokens that will be first shifted into the parser stack.
@end table
@end defun

@menu
* Grammar format::              
* Conflicts::                   
* Example::                     
@end menu

@node Grammar format, Conflicts, Grammar, Grammar
@comment  node-name,  next,  previous,  up
@section Grammar format

The function @code{wisent-compile-grammar} reads a context-free
grammars represented as an Emacs Lisp list of the form:

@lisp
(TERMINALS ASSOCS . NON-TERMINALS)
@end lisp

where:

@table @var
@item terminals
Is the list of terminal symbols used in the grammar.

@item assocs
Specify the associativity of terminals like do the
@code{%nonassoc}, @code{%left} and @code{%right} Bison's statements
(@inforef{Contextual Precedence, , bison.info}).  It is
@code{nil} or a list of elements of the form:

@lisp
(ASSOC-TYPE . ASSOC-TERMS)
@end lisp

where @var{ASSOC-TYPE} is the symbol @code{nonassoc}, @code{left} or
@code{right}, and @var{TERMS} is a list of terminal items.
@item non-terminals
Is the list of nonterminal definitions.  Each definition has the form:

@lisp
(NONTERM . RULES)
@end lisp

where @var{NONTERM} is the nonterminal
symbol defined and @var{RULES} the list of rules that describe this
nonterminal.  Each rule has the form:

@lisp
(COMPONENTS [PRECEDENCE] [ACTION])
@end lisp

where:

@table @var
@item components
Is a list of various terminals and nonterminals that are put together
by this rule.

For example,

@example
(exp ((exp ?+ exp))          ;; exp: exp '+' exp
     )                       ;;    ;
@end example

says that two groupings of type @samp{exp}, with a @samp{+} token in
between, can be combined into a larger grouping of type @samp{exp}.
 
Scattered among the components can be @dfn{middle-rule} actions.
Usually only @var{ACTION} is provided (@pxref{action}).

If @var{COMPONENTS} in a rule is nil, it means that the rule can match
the empty string.  For example, here is how to define a
comma-separated sequence of zero or more @samp{exp} groupings:

@example
(expseq  (nil)               ;; expseq: ;; empty
         ((expseq1))         ;;       | expseq1
         )                   ;;       ;

(expseq1 ((exp))             ;; expseq1: exp
         ((expseq1 ?, exp))  ;;        | expseq1 ',' exp
         )                   ;;        ;
@end example

@item precedence
Is an optional vector of one terminal item.  The rule will be given
the precedence level of this terminal.  By default the rule precedence
is the one of the last terminal in it (@inforef{Contextual Precedence,
,bison.info}).  Only terminals declared in @var{assocs} have a
precedence level@footnote{@var{assocs} defines associativity and an
implicit precedence level for given terminals.  @var{precedence} here
explicitly defines the precedence level of the rule (as the precedence
level of a terminal specified in @var{assocs})}.

@item @anchor{action}action
An action is an optional Emacs Lisp function call, like this:

@example
(identity $1)
@end example

The result of an action determines the semantic value of a rule.

From an implementation standpoint, the function call will be embedded
in a lambda expression, and several useful local variables will be
defined:

@table @code
@item $N
Where @var{N} is a positive integer.  Like in Bison, the value of
@code{$N} is the semantic value of the @var{N}th element of
@var{COMPONENTS}, starting from @code{1}.  It can be of any Lisp data
type.

@item $regionN
Where @var{N} is a positive integer.  For each @code{$N} variable
defined there is a corresponding @code{$regionN} variable.  Its value
is a pair @samp{(START-POS .  END-POS)} that represent the start and
end positions (in the lexical input stream) of the @code{$N} value.
It can be @code{nil} when the component positions are not available,
like for an empty string component for example.

@item $region
Its value is the leftmost and rightmost positions of input data
matched by all @var{COMPONENTS} in the rule.  This is a pair
@samp{(LEFTMOST-POS .  RIGHTMOST-POS)}.  It can be @code{nil} when
components positions are not available.

@item $nterm
This variable is initialized with the nonterminal symbol (@var{NONTERM})
the rule belongs to.  It could be useful to improve error reporting
or debugging.
@end table

A default value is supplied for @var{ACTION}, it is @code{(identity
$1)}.  This means that the default semantic value of a rule is
the value of its first component.

The default semantic action for a rule matching the empty string is
@code{(identity nil)}.
@end table
@end table

@node Conflicts, Example, Grammar format, Grammar
@comment  node-name,  next,  previous,  up
@section Conflicts

Wisent resolves conflicts in grammars the same way Bison does
(@inforef{Shift/Reduce , , bison.info} and @inforef{Reduce/Reduce , ,
bison.info}).

It resolves a reduce/reduce conflict by choosing to use the rule that
appears first in the grammar.

It resolves shift/reduce conflicts by choosing to shift, unless
otherwise directed by operator precedence declarations (see
@var{ASSOCS} and @var{NON-TERMINALS} specifications in @pxref{Grammar
format}).

@node Example,  , Conflicts, Grammar
@comment  node-name,  next,  previous,  up
@section Example

Here is an example to parse simple infix arithmetic expressions.  It
is explained more fully in the Bison manual: @inforef{Infix Calc,
Examples, bison.info}.  The full grammar in @dfn{WY} format (@pxref{WY
grammar format}) is available in the file @file{wisent-calc.wy}.

@example
%token <number> NUM

%nonassoc '=' ;; comparison
%left '-' '+'
%left '*' '/'
%left NEG     ;; negation--unary minus
%right '^'    ;; exponentiation

%%

input:
    line
  | input line
    (format "%s %s" $1 $2)
  ;

line:
    ';'
    @{";"@}
  | exp ';'
    (format "%s;" $1)
  ;

exp:
    NUM
    (string-to-number $1)
  | exp '=' exp
    (= $1 $3)
  | exp '+' exp
    (+ $1 $3)
  | exp '-' exp
    (- $1 $3)
  | exp '*' exp
    (* $1 $3)
  | exp '/' exp
    (/ $1 $3)
  | '-' exp %prec NEG
    (- $2)
  | exp '^' exp
    (expt $1 $3)
  | '(' exp ')'
    @{$2@}
  ;

%%
@end example

Here is the corresponding Lisp form accepted by
@code{wisent-compile-grammar}:

@lisp
'(
  ;; Terminals
  (NUM)
  
  ;; Terminal associativity & precedence
  ((nonassoc ?=)
   (left ?- ?+)
   (left ?* ?/)
   (left NEG)
   (right ?^))
  
  ;; Rules
  (input
   ((line))
   ((input line)
    (format "%s %s" $1 $2))
   )

  (line
   ((?;)
    (progn ";"))
   ((exp ?;)
    (format "%s;" $1))
   )

  (exp
   ((NUM)
    (string-to-number $1))
   ((exp ?= exp)
    (= $1 $3))
   ((exp ?+ exp)
    (+ $1 $3))
   ((exp ?- exp)
    (- $1 $3))
   ((exp ?* exp)
    (* $1 $3))
   ((exp ?/ exp)
    (/ $1 $3))
   ((?- exp) [NEG]
    (- $2))
   ((exp ?^ exp)
    (expt $1 $3))
   ((?\( exp ?\))
    (progn $2))
   )
  )
@end lisp

@node Parsing, Wisent Bovine, Grammar, Top
@comment  node-name,  next,  previous,  up
@chapter Parsing

The parser used by Wisent is a @dfn{bottom-up} parser driven by
the automaton produced by @code{wisent-compile-grammar} from a
context-free grammar (@pxref{Grammar}).

A such parser, also called a @dfn{shift-reduce} parser, performs four
elementary operations depending on states popped up from a state
stack.  Each operation pushes a new state into the state stack.

The four elementary operations performed are:

@table @dfn
@item shift
This operation pushes the value of the last lexical token read (the
look-ahead token) into a value stack and reads a new one. @xref{Writing
a lexer}.
@item reduce
This operation replaces a nonterminal by its semantic value.  The
nonterminal component values are popped from the value stack and
reduced by the semantic action associated to this nonterminal.  The
result is pushed back on top of value stack. @xref{Writing semantic
actions}.
@item accept
This operation stops the parser which has successfully processed all
input tokens.  The semantic value of the start nonterminal is on top
of the value stack. 
@item error
This operation interrupts parsing because of a syntax error (an
unexpected token in input).  At this point the parser can call a
recovery routine and try to resume (@pxref{Error recovery}) or simply
issue an error message (@pxref{Report errors}) and stop.
@end table

The parser is entered by calling the following function:

@defun wisent-parse automaton lexer &optional error start
Parse input using the automaton specified in @var{automaton}.

@table @var
@item automaton
Is an LALR(1) automaton generated by
@code{wisent-compile-grammar}. @xref{Grammar}.
@item lexer
Is a function with no argument called by the parser to obtain the next
terminal (token) in input. @xref{Writing a lexer}.
@item error
Is an optional reporting function called when a parse error occurs.
It receives a message string to report.  It defaults to the function
@code{error}. @xref{Report errors}.
@item start
Specify the start symbol (nonterminal) used by the parser as its goal.
It defaults to the start symbol defined in the grammar. @xref{Grammar}.
@end table
@end defun

@menu
* Writing a lexer::             What the parser must receive.
* Writing semantic actions::    
* Report errors::               
* Error recovery::              
@end menu

@node Writing a lexer, Writing semantic actions, Parsing, Parsing
@comment  node-name,  next,  previous,  up
@subsection What the parser must receive

It is important to understand that the parser does not parse
characters, but lexical tokens, and does not know anything about
characters and streams!

Reading input data to produce lexical tokens is performed by a lexer
(also called a scanner) in a lexical analysis step, before the syntax
analysis step performed by the parser.  The parser automatically calls
the lexer when it needs the next token to parse.

A Wisent's lexer is an Elisp function with no argument.  It must
return a valid lexical token of the form:

@lisp
(SYMBOL VALUE [START . END])
@end lisp

@table @var
@item symbol
Is the unique symbol or character value identifying a terminal as
specified in the grammar (@pxref{Grammar}).
@item value
Is the actual value of @var{symbol}.  It can be of any valid Emacs
Lisp data type.
@item start
@itemx end
Are the optionals beginning and end positions of @var{value} in the
input stream.
@end table

When there are no more tokens to read the lexer must return the token
@code{(list 'wisent-eoi-term)} to each request.

@code{wisent-flex} is an example of a lexer that reads Semantic's
syntactic tokens and produces lexical tokens.  @xref{Wisent Flex}.

To call the lexer in a semantic action use the function
@code{wisent-lexer} (@pxref{Writing semantic actions}).

@node Writing semantic actions, Report errors, Writing a lexer, Parsing
@comment  node-name,  next,  previous,  up
@subsection Variables and macros useful in grammar actions.

@defvar wisent-input
The last token read.
The actual value of this variable is local to the parser.
@end defvar

@defun wisent-lexer
Obtain the next terminal in input.
@end defun

@defun wisent-region &rest positions
Return the start/end positions of the region including @var{POSITIONS}.
Each element of @var{POSITIONS} is a pair (@var{START-POS} .
@var{END-POS}) or nil.  The returned value is the pair
(@var{MIN-START-POS} . @var{MAX-END-POS}) or @code{nil} if no
@var{POSITIONS} are available.
@end defun

@node Report errors, Error recovery, Writing semantic actions, Parsing
@comment  node-name,  next,  previous,  up
@subsection The error reporting function

When the parser encounters a syntax error it calls a user-defined
function.  It must be an Elisp function with one argument: a string
containing the message to report.

By default the parser uses the standard Elisp function @code{error} to
report error message and terminate.

At this point the variable @code{wisent-input} contains the unexpected
token as returned by the lexer.

The error reporting function can be called from a semantic action too
using the special macro @code{wisent-error}.  When called from a
semantic action entered by error recovery (@pxref{Error recovery}) the
value of the variable @code{wisent-recovering} is non-nil.

@node Error recovery,  , Report errors, Parsing
@comment  node-name,  next,  previous,  up
@subsection Error recovery

The error recovery mechanism of the Wisent's parser conforms to one
Bison use (@inforef{Error Recovery, , bison.info}).
 
To recover from a syntax error you must write rules to recognize the
special token @code{error}.  This is a terminal symbol that is
automatically defined and reserved for error handling.

When the parser encounters a syntax error, it pops the state stack
until it finds a state that allows shifting the @code{error} token.
After it has been shifted, if the old look-ahead token is not
acceptable to be shifted next, the parser reads tokens and discards
them until it finds a token which is acceptable.

Strategies for error recovery depend on the choice of error rules in
the grammar.  A simple and useful strategy is simply to skip the rest
of the current statement if an error is detected:

@example
(stmnt (( error ?; )) ;; on error, skip until ';' is read
       )
@end example

It is also useful to recover to the matching close-delimiter of an
opening-delimiter that has already been parsed:

@example
(primary (( ?@{ expr  ?@} ))
         (( ?@{ error ?@} ))
         ...
         )
@end example

Note that error recovery rules may have actions, just as any other
rules can.  Here are some predefined variables and functions or macros
useful in such actions:

@defvar wisent-nerrs
The number of parse errors encountered so far.
@end defvar

@defvar wisent-recovering
Non-@code{nil} when the parser is recovering.
The actual value of this variable is local to the parser.
@end defvar

@defun wisent-error msg
Call the language specific error reporting function with message
@var{MSG}. @xref{Report errors}.


See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@defun wisent-errok
Resume generating error messages immediately for subsequent syntax
errors.

The parser suppress error message for syntax errors that happens
shortly after the first, until three consecutive input tokens have
been successfully shifted.

Calling @code{wisent-errok} in an action, make error messages resume
immediately.  No error messages will be suppressed if your call it in
an error rule's action.

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@defun wisent-clearin
Discard the current look-ahead token.
This will cause a new token to be read.

In an error rule's action the previous look-ahead token is reanalyzed
immediately.  @code{wisent-clearin} may be called to clear this token.

For example, suppose that on a parse error, an error handling routine
is called that advances the input stream to some point where parsing
should once again commence.  The next symbol returned by the lexical
scanner is probably correct.  The previous look-ahead token ought to
be discarded with @code{wisent-clearin}.

See implementation of the function @code{wisent-skip-token} below, for
an example of use.
@end defun

@defun wisent-set-region start end
Change the region of text matched by the current nonterminal.
@var{START} and @var{END} are respectively the beginning and end
positions of the region occupied by the group of components associated
to this nonterminal.  If @var{START} or @var{END} values are not a
valid positions the region is set to nil.

For example, the function @code{wisent-skip-block} described below
uses it to safely set the region to the start/end positions of the
current block of code.
@end defun

@defun wisent-skip-token
Skip an invalid token and try to continue parsing.

It is implemented like this:

@lisp
(defsubst wisent-skip-token ()
  "Skip an invalid token and try to continue parsing.
To be used in grammar recovery actions."
  (wisent-error (format "Skipping invalid '%s'" $nterm))
  ;; Clear the lookahead token
  (if (eq (car wisent-input) wisent-eoi-term)
      ;; does nothing at EOI to avoid infinite recovery loop
      nil
    (run-hook-with-args 'wisent-skip-token-hook wisent-input)
    (wisent-clearin)
    (wisent-errok)))
@end lisp
@end defun

@defun wisent-skip-block
Safely skip a block and try to continue parsing.
A block is data between an open-delimiter (syntax class @code{(}) and
a matching close-delimiter (syntax class @code{)}):

@example
(a parenthesized block)
[a block between brackets]
@{a block between braces@}
@end example

The following example uses @code{wisent-skip-block} to safely skip a
block delimited by @samp{LBRACE} (@code{@{}) and @samp{RBRACE}
(@code{@}}) tokens:

@example
(block ((LBRACE RBRACE))
       ((LBRACE error)
        (wisent-skip-block))
       )
@end example
@end defun

@node Wisent Bovine, Index, Parsing, Top
@comment  node-name,  next,  previous,  up
@chapter How to use Wisent with Semantic


@menu
* WY grammar format::           
* Grammar styles::              
* Wisent Flex::                 
@end menu

@node WY grammar format, Grammar styles, Wisent Bovine, Wisent Bovine
@comment  node-name,  next,  previous,  up
@section WY grammar format

@node Grammar styles, Wisent Flex, WY grammar format, Wisent Bovine
@comment  node-name,  next,  previous,  up
@section Grammar styles

There are mainly two styles to write a Wisent's grammar intended to be
used with the Semantic tool set.

@menu
* Bovine style::                
* Bison style::                 
@end menu

@node Bovine style, Bison style, Grammar styles, Grammar styles
@comment  node-name,  next,  previous,  up
@subsection Bovine style

The @dfn{bovine style} is the preferred style to use with Semantic.
It relies on the bovinator back-end mechanism which parses top-level
nonterminals one at a time and automagically skip unexpected lexical
tokens in input.

Each top-level nonterminal must produces a @dfn{raw semantic token} by
calling the function @code{wisent-token} with the appropriate
parameters.

Bovination then automatically translate raw tokens into @dfn{cooked
semantic tokens}, updating the raw token structure with internal
properties and buffer related data.

After parsing completed it results in a list of cooked tokens which
becomes the value of @code{semantic-toplevel-bovine-cache}.

@defun wisent-token &rest return-val
Return a raw Semantic token including @var{RETURN-VAL}.
Should be used in Semantic actions to build the bovine cache.
@end defun

@menu
* Top level nonterminals::      
* Bovine style example::        
@end menu

@node Top level nonterminals, Bovine style example, Bovine style, Bovine style
@comment  node-name,  next,  previous,  up
@subsubsection Top level nonterminals

To be done!

@node Bovine style example,  , Top level nonterminals, Bovine style
@comment  node-name,  next,  previous,  up
@subsubsection Bovine style example

The following example is a snippet of the bovine style Java grammar
provided in the Semantic distribution in the file
@file{wisent-java-tags.wy}.

@example
formal_parameter_list
  : PAREN_BLOCK
    (EXPANDFULL $1 formal_parameters)
  ;

formal_parameters
  : LPAREN
    ()
  | RPAREN
    ()
  | formal_parameter COMMA
  | formal_parameter RPAREN
  ;

formal_parameter
  : formal_parameter_modifier_opt type variable_declarator_id
    (wisent-token $3 'variable $2 nil
                  (ASSOC typemodifiers $1)
                  nil)
  ;
@end example

It shows the use of the @code{EXPANDFULL} built-in function to parse a
@samp{PAREN_BLOCK} which contains a @samp{formal_parameter_list}.
Actually, @code{EXPANDFULL} tells to recursively bovinate
@samp{formal_parameters} inside @samp{PAREN_BLOCK}.  The parser then
iterates until it digested all available input data inside the
@samp{PAREN_BLOCK}, trying to match any of the
@samp{formal_parameters} rules:

@itemize
@item
@samp{LPAREN}
@item
@samp{RPAREN}
@item
@samp{formal_parameter COMMA}
@item
@samp{formal_parameter RPAREN}
@end itemize

At each iteration it will return a @samp{formal_parameter} raw token,
or nil to skip unwanted (single @samp{LPAREN} or @samp{RPAREN} for
example) or unexpected input data.

@node Bison style,  , Bovine style, Grammar styles
@comment  node-name,  next,  previous,  up
@subsection Bison style

What we call the @dfn{Bison style} is actually the traditional style
of Bison's grammars.  Compared to bovine style, it is not
straightforward to use grammars written in Bison style in Semantic.
Mainly because such grammars are designed to parse the whole input
data in one pass, and don't use the bovinator back-end mechanism
(@pxref{Bovine style}).  With Bison style the parser is called once to
parse the grammar start symbol, which is the only known top-level
nonterminal.

The first consequence is that syntax errors are not automatically
handled by Semantic.  Thus, it is necessary to explicitly handle them
at the grammar level, providing error recovery rules to skip
unexpected input data.

The second consequence is that the bovinator can't do automatic raw to
cooked token translation, excepted for the start nonterminal value.
So it is also necessary to explicitly return cooked semantic tokens
from concerned semantic actions by calling the function
@code{wisent-cooked-token} with the appropriate parameters.

@defun wisent-cooked-token &rest return-val
Return a cooked Semantic token including @var{RETURN-VAL}.
Should be used in Semantic actions to build the bovine cache.
@end defun

@menu
* Bison style example::         
@end menu

@node Bison style example,  , Bison style, Bison style
@comment  node-name,  next,  previous,  up
@subsubsection Bison style example

The following example is a snippet of the Bison style Java grammar
provided in the Semantic distribution in the file
@file{wisent-java.wy}.

@example
formal_parameter_list
  : formal_parameter_list COMMA formal_parameter
    (cons $3 $1)
  | formal_parameter
    (list $1)
  ;

formal_parameter
  : formal_parameter_modifier_opt type variable_declarator_id
    (wisent-cooked-token $3 'variable $2 nil
                         (ASSOC typemodifiers $1)
                         nil)
  ;
@end example

@node Wisent Flex,  , Grammar styles, Wisent Bovine
@comment  node-name,  next,  previous,  up
@section The Wisent Flex lexer

@defun wisent-flex
Return the next available lexical token.

Eat syntactic tokens produced by @code{semantic-flex}, available in
variable @code{wisent-flex-istream}, and return Wisent's lexical
tokens.

See documentation of @code{semantic-flex-tokens} for details on the
syntactic tokens returned by @code{semantic-flex}.

In most cases one syntactic token is mapped to one lexical token.  But
in certain cases several successive syntactic tokens can be mapped to
one lexical tokens.  A common case is given by arithmetic operators
which can be made of multiple punctuations.

Also the mapping between syntactic tokens and lexical ones uses regexp
match by default, but can use string comparison too.

The rules specifying how to do the mapping are defined in two symbol
tables:

@table @code
@item semantic-flex-keywords-obarray
The keyword table.
@item wisent-flex-tokens-obarray
The token table.
@end table

Keywords are directly mapped to equivalent Wisent's lexical tokens
like this (@var{SF}- prefix means @code{semantic-flex}, @var{WF}-
@code{wisent-flex}):

@example
@result{(SF-KEYWORD start . end) } (WF-KEYWORD "name" start . end)
@end example

Mapping of other tokens obeys to rules in the token table.  Here is an
example on how to define the mapping of @code{'punctuation} syntactic
tokens.

@enumerate
@item
Add (@code{intern}) the symbol @code{'punctuation} into the token
table.

@item
Set its value to the mapping rules to use.  Mapping rules are an alist
of @samp{(WF-TOKEN . MATCHER)} elements.  @var{WF-TOKEN} is the
category of the Wisent's lexical token (for example @samp{'OPERATOR}).
@var{MATCHER} is the regular expression used to filter input data (for
example @samp{"[+-]"}).  The first element of the mapping rule alist
defines a default matching rule. It must be @code{nil} or have the
form @samp{(WF-TOKEN)}.  When there is no mapping rule that matches
the syntactic token value, the default @var{WF-TOKEN} or @code{nil} is
returned.

Thus, if the syntactic token symbol @code{'punctuation} has the
mapping rules @samp{'(nil (OPERATOR . "[+-]"))}, the following token:

@example
(punctuation 1 . 2)
@end example

will be mapped to the lexical token

@example
(OPERATOR "+" 1 . 2)
@end example

if the buffer contained @samp{+} between positions 1 and 2.

To define multiple matchers for the same @var{WF-TOKEN} just give
several @samp{(WF-TOKEN . MATCHER)} values.  @var{MATCHER}s will be
tried in sequence until one matches.

@item
Optionally customize how @code{wisent-flex} will interpret mapping
rules, using symbol properties.

The following properties are recognized:

@table @code
@item string
If non-@code{nil} MATCHERs are interpreted as strings instead of
regexps, and matching uses direct string comparison.  This could speed
up things in certain cases.

@item multiple
non-@code{nil} indicates to lookup at multiple successive syntactic
tokens and try to match the longest one.

@item char-literal
non-@code{nil} indicates to return the first character of the
syntactic token value as the lexical token category.  It is the
default for punctuation, open-paren and close-paren syntactic tokens.
Use this property when grammar contains references to character
literals.

@item handler
If non-@code{nil} must specify a function with no argument that will
be called first to map the syntactic token.  It must return a lexical
token or @code{nil}, and update the input stream in variable
@code{wisent-flex-istream} accordingly.
@end table

The following example maps multiple punctuations to operators and use
string comparison:

@example
(let ((entry (intern 'punctuation token-table)))
  (set entry '(nil ;; No default mapping
               (LSHIFT . "<<") (RSHIFT . ">>")
               (LT     . "<")  (GT     . ">")))
  (put entry 'string   t)
  (put entry 'multiple t))
@end example
@end enumerate
@end defun

@node Index,  , Wisent Bovine, Top
@comment  node-name,  next,  previous,  up
@unnumbered Index

@printindex cp

@contents
@bye

@c  LocalWords:  Wisent
