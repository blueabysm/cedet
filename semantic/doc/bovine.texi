\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename bovine.info
@set TITLE  Bovine parser development
@set AUTHOR Eric M. Ludlam, David Ponce, and Richard Y. Kim
@settitle @value{TITLE}

@c *************************************************************************
@c @ Header
@c *************************************************************************

@c Merge all indexes into a single index for now.
@c We can always separate them later into two or more as needed.
@syncodeindex vr cp
@syncodeindex fn cp
@syncodeindex ky cp
@syncodeindex pg cp
@syncodeindex tp cp

@c @footnotestyle separate
@c @paragraphindent 2
@c @@smallbook
@c %**end of header

@copying
This manual documents Bovine parser development in Semantic

Copyright @copyright{} 1999, 2000, 2001, 2002, 2003, 2004 Eric M. Ludlam
Copyright @copyright{} 2001, 2002, 2003 David Ponce
Copyright @copyright{} 2002, 2003 Richard Y. Kim

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being list their titles, with the Front-Cover Texts
being list, and with the Back-Cover Texts being list.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.
@end quotation
@end copying

@ifinfo
@dircategory Emacs
@direntry
* Semantic bovine parser development: (bovine).
@end direntry
@end ifinfo

@iftex
@finalout
@end iftex

@c @setchapternewpage odd
@c @setchapternewpage off

@ifinfo
This file documents parser development with the bovine parser generator
@emph{Infrastructure for parser based text analysis in Emacs}

Copyright @copyright{} 2002 @value{AUTHOR}
@end ifinfo

@titlepage
@sp 10
@title @value{TITLE}
@author by @value{AUTHOR}
@vskip 0pt plus 1 fill
Copyright @copyright{} 1999, 2000, 2001, 2002, 2003 @value{AUTHOR}
@page
@vskip 0pt plus 1 fill
@insertcopying
@end titlepage
@page

@c MACRO inclusion
@include semanticheader.texi


@c *************************************************************************
@c @ Document
@c *************************************************************************

@node top
@top @value{TITLE}

The bovine parser is the original semantic parser, and is an
implementation of an LL parser.  It is good for simple langauges.  It
has many conveniences making grammar writing easy.  The conveniences
make it less flexible than a full LALR @emph{bison} style grammar.

Bovine parsers are stored in files with a @file{.by} extension.
When compiled, the contents is converted into a file of the form
@file{NAME-by.el}.  This, in turn is byte compiled.
@inforef{Grammar Programming Environment, ,lang-support-guide}.

A bovine parser file has the following top level structure.
Text in <angle> brackes should be replaced with apropriate values.

@example
%package <language>
%languagemode  <mode name>
%start         <starting rule>
%scopestart    <scope starting rule>

<DECLARATIONS>

%%

<RULES>
@end example

The comment character is @asis{;}, as with Emacs Lisp.

@menu
* %start::                      The starting rules for the grammar.
* %languagemode::               The Emacs major mode associate with your grammar.
* %token::                      Defining new lexical tokens
* Bovine Grammar Rules::        Rules used to parse a language
* Optional Lambda Expression::  Actions to take when a rule is matched
* Bovine Examples::             Simple Samples
@end menu

@node %start
@chapter %start

In Bison, one and only one nonterminal is designated as the
``start'' symbol.
In @semantic{}, one or more nonterminals can be designated as the
``start'' symbol.

One or more start symbols can be explicitly declared following
the @b{%start}  keyword separated by spaces.

If no @b{%start} keyword is used in a grammar, then the start token
is called @b{bovine-toplevel}.  When it is used, then the rule named
by the @b{%start} token is renamed internally to @b{bovine-toplevel}
so it can be found by the parser harness.

If one or more explicit @b{start} symbols are declared, then
the very first is used.

@ignore
Submitted By: Joseph Kiniry (kiniry)
>Assigned to: Richard Y. Kim (emacsman)
Summary: Semantics of %start and %scopestart settings still unclear.

Initial Comment:
The rule specified with %start is a legal topmost
production rule, but the first rule in a BNF file is
still used as bovine-toplevel.  This is not made clear.

If a rule is specified with %scopestart then that rule
is not used/generated in the corresponding table.  This
leads to an erroneous disconnected grammar
specification.  I think that the use of this variable
needs to be reviewed and its documentation needs to be
clarified.
@end ignore

@node %languagemode
@chapter %languagemode

@c >   A while back, I updated semantic-grammer.el to auto-run the setup
@c > function in all modes of the correct type.  It uses %languagemode to
@c > figure out what buffers to look in.  %languagemode doesn't seem to be
@c > used in wisent though.  I'm not sure if it should be or not.  Perhaps
@c > no cases call for it yet.
@c 
@c %languagemode is not used by the parser itself, but is used by
@c grammar tools, when the grammar provides it (wisent-java-tags.wy
@c for example).
@c 

@node %token
@chapter %token

In the bovine parser, the @b{%token} and related @b{%put} command
control the creation of additional lexical tokens types called
@emph{keywords}.

The @b{%token} has two forms.

@table @asis
@item %token NAME ``name''
In this form, the new lexical token @var{NAME} is declared matched to the
keyword ``name'', a string.  ``name'' must be a valid @emph{symbol}
token @inforef{Writing Lexers, ,lang-support-guide}.
@item %token <LEXICALTYPE> NAME ``regexp''
In this form, the new lexical token @var{NAME} is created which consists of
characters of the lexical type @var{LEXICALTYPE}.  The <angle> brackets are
a part of the syntax.  These lexical characters are matched against
@var{REGEXP}.
@end table

Internally, symbol tokens created with the first form are added to a
lexical keyword table @inforef{Keywords, , lang-support-guide}.  The other types of lexical
tokens are substitued into the rules, and do not appear in the Emacs
Lisp representation of the grammar.

A related command to @b{%token} is @b{%put}.  This works much the
same way as the Emacs Lisp command @dfn{put}, in that it associates a
property with a value on the named token.

@defun Fcn %put NAME PROPERTY VALUE
@var{NAME} is the name of the token to add a value to.
@var{PROPERTY} is a symbol representing the property whose value is
to be modified.
@var{VALUE} is an Emacs Lisp form to be used as a value on that
property.
@end defun

@node Bovine Grammar Rules
@chapter Bovine Grammar Rules

The rules are what allow the compiler to create tags from a language
file.  Once the setup is done in the prologue, you can start writing
rules.

@example
RESULT : MATCH1 (optional-lambda-expression)
       | MATCH2 (optional-lambda-expression)
       ;
@end example

@var{RESULT} is a non-terminal, or a token synthesized in your grammar.
@var{MATCH} is a list of elements that are to be matched if @var{RESULT}
is to be made.  The optional lambda expression is a list containing
simplified rules for concocting the parse tree.

In bison, each time an element of a @var{MATCH} is found, it is
"shifted" onto the parser stack.  (The stack of matched elements.)  When
all of @var{MATCH1}'s elements have been matched, it is "reduced" to
@var{RESULT}.  @xref{(bison)Algorithm}.

The first @var{RESULT} written into your language specification should
be @code{bovine-toplevel}, or the symbol specified with @code{%start}.
When starting a parse for a file, this is the default token iterated
over.  You can use any token you want in place of @code{bovine-toplevel}
if you specify what that nonterminal will be with a @code{%start} token
in the settings section.

@var{MATCH} is made up of symbols and strings.  A symbol such as
@code{foo} means that a syntactic token of type @code{foo} must be
matched.  A string in the mix means that the previous symbol must have
the additional constraint of exactly matching it.  Thus, the
combination:

@example
symbol "moose"
@end example

means that a symbol must first be encountered, and then it must
@code{string-match "moose"}.  Be especially careful to remember that the
string is a regular expression.  The code:

@example
punctuation "."
@end example

will match any punctuation.

For the above example in bison, a LEX rule would be used to create a new
token @var{MOOSE}.  In this case, the @var{MOOSE} token would appear.
For the bovinator, this task was mixed into the language definition to
simplify implementation, though Bison's technique is more efficient.

To make a symbol match explicitly for keywords, for example, you can use
the @code{%token} command in the settings section to create new symbols.

@example
%token MOOSE "moose"

find_a_moose: MOOSE
            ;
@end example

will match ``moose'' explicitly, unlike the previous example where moose
need only appear in the symbol.  This is because ``moose'' will be
converted to @var{MOOSE} in the lexical analysis stage.  Thus the symbol
@var{MOOSE} won't be available any other way.

If we specify our token in this way:

@example
%token MOOSE symbol "moose"

find_a_moose: MOOSE
            ;
@end example

then @code{MOOSE} will match the string "moose" explicitly, but it won't
do so at the lexical level, allowing use of the text "moose" in other
forms of regular expressions.

Non symbol tokens are also allowed.  For example:

@example
%token PERIOD punctuation "."

filename : symbol PERIOD symbol
         ;
@end example

will explicitly match one period when used in the above rule.

@section Order of MATCH rules

If a rule has multiple matches, order is important, for example

@example
headerfile : symbol PERIOD symbol
           | symbol
           ;
@end example

would match ``foo.h'' or the c++ header ``foo''.
The bovine parser will first attempt to match the long form, and then
the short form.  If they were in reverse order, then the long form
would never be tested.

@c @xref{Default syntactic tokens}.

@node Optional Lambda Expression
@chapter Optional Lambda Expressions

The OLE (Optional Lambda Expression) is converted into a bovine lambda
This lambda has special short-cuts to simplify reading the Emacs BNF
definition.  An OLE like this:

@example
( $1 )
@end example

results in a lambda return which consists entirely of the string
or object found by matching the first (zeroth) element of match.
An OLE like this:

@example
( ,(foo $1) )
@end example

executes `foo' on the first argument, and then splices its return
into the return list whereas:

@example
( (foo $1) )
@end example

executes foo, and that is placed in the return list.

Here are other things that can appear inline:
@table @code
@item $1
the first object matched.
@item ,$1
the first object spliced into the list (assuming it is a list from a
non-terminal)
@item '$1
the first object matched, placed in a list.  i.e. ( $1 )
@item foo
the symbol foo (exactly as displayed)
@item (foo)
a function call to foo which is stuck into the return list.
@item ,(foo)
a function call to foo which is spliced into the return list.
@item '(foo)
a function call to foo which is stuck into the return list in a list.
@item (EXPAND $1 nonterminal depth)
a list starting with EXPAND performs a recursive parse on the token
passed to it (represented by $1 above.)  The semantic list is a common
token to expand, as there are often interesting things in the list.
The @var{nonterminal} is a symbol in your table which the bovinator will
start with when parsing.  @var{nonterminal}'s definition is the same as
any other nonterminal.  @var{depth} should be at least 1 when
descending into a semantic list.
@item (EXPANDFULL $1 nonterminal depth)
is like EXPAND, except that the parser will iterate over
@var{nonterminal} until there are no more matches.  (The same way the
parser iterates over @code{bovine-toplevel}. This lets you have
much simpler rules in this specific case, and also lets you have
positional information in the returned tokens, and error skipping.
@item (ASSOC symbol1 value1 symbol2 value2 ... )
This is used for creating an association list.  Each @var{SYMBOL} is
included in the list if the associated @var{VALUE} is non-nil.  While
the items are all listed explicitly, the created structure is an
association list of the form:
@example
( ( symbol1 . value1) (symbol2 . value2) ... )
@end example
@item (TAG "name" class &rest attributes)
This creats one tag in the current buffer.  @var{name} is a string
that represents the tag in the langauge.  The @var{class} is the kind
of tag being create, such as @code{function}, or @code{variable},
though any symbol will work.  @var{attributes} is a set of labeled
values such as @code{:const t :parent "parenttype"}.
@item (TAG-VARIABLE "name" type default-value &rest attributes)
@itemx (TAG-FUNCTION "name" type arg-list &rest attributes)
@itemx (TAG-TYPE "name" type members parents &rest attributes)
@itemx (TAG-INCLUDE "name" system-flag &rest attributes)
@itemx (TAG-PACKAGE "name" detail &rest attributes)
@itemx (TAG-CODE "name" detail &rest attributes)
Create a tag with @var{name} of the given @var{class}.
See @inforef{Creating Tags, , semantic-appdev.info} for the lisp
functions these translate into.
@end table

If the symbol @code{%quotemode backquote} is specified, then use
@code{,@@} to splice a list in, and @code{,} to evaluate the expression.
This lets you send @code{$1} as a symbol into a list instead of having
it expanded inline.

@node Bovine Examples
@chapter Examples

The rule:

@example
SYMBOL : symbol
@end example

is equivalent to

@example
SYMBOL : symbol
         ( $1 )
@end example

which, if it matched the string "A", would return

@example
( "A" )
@end example

If this rule were used like this:

@example
ASSIGN: SYMBOL punctuation "=" SYMBOL
        ( $1 $3 )
@end example

it would match "A=B", and return

@example
( ("A") ("B") )
@end example

The letters A and B come back in lists because SYMBOL is a nonterminal,
not an actual lexical element.

to get a better result with nonterminals, use @asis{,} to splice lists
in like this;

@example
ASSIGN: SYMBOL punctuation "=" SYMBOL
        ( ,$1 ,$3 )
@end example

which would return

@example
( "A" "B" )
@end example
