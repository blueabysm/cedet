@ignore
@node Application Developer's Guide
@chapter Application Developer's Guide
@c This 'ignore' section fools texinfo-all-menus-update into creating
@c proper menus for this chapter.
@end ignore

A @semantic{} application takes the semantic tags generated
by semantic parsers then provides useful services to the user.
See @ref{Semantic User's Guide} for a list of such applications.

An application developer needs to know
@itemize @bullet
@item when to invoke the parser to generate or regenerate the tag lists.
@item how to access the tag lists.
@item how to access information about each tag.
@end itemize

This chapter describes @semantic{} fuctions and concepts an application
developer needs to know to perform all of the tasks just listed.

@menu
* Semantic Tags::               
* Tag Tables::                  Working with streams of nonterminals.
* Tags at Point::               Finding tags at point.
* Tag Sorting::                 Reorganizing streams.
* Tag Completion::              Completing read functions.
* Override Methods::            Language dependent functions covering
                                conversion to text strings, language dependent
                                queries and local context information
* Parser Hooks::                How to know when tags change.
* Example Programs::            Simple programming examples.
* Current Context::             
@end menu

@node Semantic Tags
@section Semantic Tags

@lowersections
@include tags.texi
@raisesections

@node Tag Tables
@section tag tables

These functions take some key, and returns information found in a tag
table.  Some will return one tag (the first matching item found.)
Others will return a list of all items matching a given criterion.
All these functions work regardless of a buffer being in memory or
not.

@defun semantic-brute-find-first-tag-by-name name streamorbuffer &optional search-parts search-include
Find a tag @var{NAME} within @var{STREAMORBUFFER}.  @var{NAME} is a string.
If @var{SEARCH-PARTS} is non-@code{nil}, search children of tags.
If @var{SEARCH-INCLUDE} is non-@code{nil}, search include files.

Use @dfn{semantic-find-first-tag-by-name} instead.

@obsolete{semantic-find-nonterminal-by-name,semantic-brute-find-first-tag-by-name}
@end defun

@defun semantic-brute-find-tag-by-property property value streamorbuffer &optional search-parts search-includes
Find all tags with @var{PROPERTY} equal to @var{VALUE} in @var{STREAMORBUFFER}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-property,semantic-brute-find-tag-by-property}
@end defun

@defun semantic-brute-find-tag-by-attribute attr streamorbuffer &optional search-parts search-includes
Find all tags with a given @var{ATTR} in @var{STREAMORBUFFER}.
@var{ATTR} is a symbol key into the attributes list.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-extra-spec,semantic-brute-find-tag-by-attribute}
@end defun

@defun semantic-brute-find-tag-by-attribute-value attr value streamorbuffer &optional search-parts search-includes
Find all tags with a given @var{ATTR} equal to @var{VALUE} in @var{STREAMORBUFFER}.
@var{ATTR} is a symbol key into the attributes list.
@var{VALUE} is the value that @var{ATTR} should match.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-extra-spec-value,semantic-brute-find-tag-by-attribute-value}
@end defun

@defun semantic-brute-find-tag-by-position position streamorbuffer &optional nomedian
Find a nonterminal covering @var{POSITION} within @var{STREAMORBUFFER}.
@var{POSITION} is a number, or marker.  If @var{NOMEDIAN} is non-@code{nil}, don't do
the median calculation, and return nil.

@obsolete{semantic-find-nonterminal-by-position,semantic-brute-find-tag-by-position}
@end defun

@defun semantic-brute-find-innermost-tag-by-position position streamorbuffer &optional nomedian
Find a list of tags covering @var{POSITION} within @var{STREAMORBUFFER}.
@var{POSITION} is a number, or marker.  If @var{NOMEDIAN} is non-@code{nil}, don't do
the median calculation, and return nil.
This function will find the topmost item, and recurse until no more
details are available of findable.

@obsolete{semantic-find-innermost-nonterminal-by-position,semantic-brute-find-innermost-tag-by-position}
@end defun

@defun semantic-brute-find-tag-by-class class streamorbuffer &optional search-parts search-includes
Find all tags with a class @var{CLASS} within @var{STREAMORBUFFER}.
@var{CLASS} is a symbol representing the class of the tags to find.
See @dfn{semantic-tag-class}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

Use @code{semantic-find-tag-by-class} instead.

@obsolete{semantic-find-nonterminal-by-token,semantic-brute-find-tag-by-class}
@end defun

@defun semantic-brute-find-tag-standard streamorbuffer &optional search-parts search-includes
Find all tags in @var{STREAMORBUFFER} which define simple class types.
See @dfn{semantic-tag-class}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-standard,semantic-brute-find-tag-standard}
@end defun

@defun semantic-brute-find-tag-by-type type streamorbuffer &optional search-parts search-includes
Find all tags with type @var{TYPE} within @var{STREAMORBUFFER}.
@var{TYPE} is a string which is the name of the type of the tags returned.
See @dfn{semantic-tag-type}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-type,semantic-brute-find-tag-by-type}
@end defun

@defun semantic-brute-find-tag-by-function function streamorbuffer &optional search-parts search-includes
Find all tags for which FUNCTION's value is non-@code{nil} within @var{STREAMORBUFFER}.
@var{FUNCTION} must return non-@code{nil} if an element of @var{STREAM} will be included
in the new list.

If optional argument @var{SEARCH-PARTS} is non-@code{nil}, all sub-parts of tags
are searched.  The overloadable function @code{semantic-tag-componenets} is
used for the searching child lists.  If @var{SEARCH-PARTS} is the symbol
@code{'positiononly}, then only children that have positional information are
searched.

If @var{SEARCH-INCLUDES} is non-@code{nil}, then all include files are also
searched for matches.  This parameter hasn't be active for a while
and is obsolete.

@obsolete{semantic-find-nonterminal-by-function,semantic-brute-find-tag-by-function}
@end defun

@defun semantic-brute-find-first-tag-by-function function streamorbuffer &optional search-parts search-includes
Find the first nonterminal which @var{FUNCTION} match within @var{STREAMORBUFFER}.
@var{FUNCTION} must return non-@code{nil} if an element of @var{STREAM} will be included
in the new list.

The following parameters were never implemented.

If optional argument @var{SEARCH-PARTS}, all sub-parts of tags are searched.
The overloadable function @dfn{semantic-tag-components} is used for
searching.
If @var{SEARCH-INCLUDES} is non-@code{nil}, then all include files are also
searched for matches.

@obsolete{semantic-find-nonterminal-by-function-first-match,semantic-brute-find-first-tag-by-function}
@end defun

@c @defun semantic-recursive-find-nonterminal-by-name name buffer
@c Recursivly find the first occurance of @var{NAME}.
@c Start search with @var{BUFFER}.  Recurse through all dependencies till
@c found.  The return item is of the form (@var{BUFFER} @var{TOKEN})
@c where @var{BUFFER} is the buffer in which @var{TOKEN} (the token found
@c to match @var{NAME}) was found.
@c 
@c @var{THIS} ISN'T @var{USED} @var{IN} @var{SEMANTIC}.  @var{DELETE}
@c @var{ME} @var{SOON}.
@c @end defun

@node Tags at Point
@section Tags at Point

When you need to get the tag the cursor is on, there is a more
efficient mechanism than using
@code{semantic-brute-find-tag-by-position}.  This mechanism directly
queries the overlays the parsing step leaves in the buffer.  This
provides for very rapid retrieval of what function or variable the
cursor is currently in.
@refill

These functions query the current buffer's overlay system for tags.

@defun semantic-find-tag-by-overlay &optional positionormarker buffer
Find all tags covering @var{POSITIONORMARKER} by using overlays.
If @var{POSITIONORMARKER} is @code{nil}, use the current point.
Optional @var{BUFFER} is used if @var{POSITIONORMARKER} is a number, otherwise the current
buffer is used.  This finds all tags covering the specified position
by checking for all overlays covering the current spot.  They are then sorted
from largest to smallest via the start location.

@obsolete{semantic-find-nonterminal-by-overlay,semantic-find-tag-by-overlay}
@end defun

@defun semantic-find-tag-by-overlay-in-region start end &optional buffer
Find all tags which exist in whole or in part between @var{START} and @var{END}.
Uses overlays to determine positin.
Optional @var{BUFFER} argument specifies the buffer to use.

@obsolete{semantic-find-nonterminal-by-overlay-in-region,semantic-find-tag-by-overlay-in-region}
@end defun

@defun semantic-current-tag
Return the current tag in the current buffer.
If there are more than one in the same location, return the
smallest tag.  Return @code{nil} if there is no tag here.

@obsolete{semantic-current-nonterminal,semantic-current-tag}
@end defun

@defun semantic-current-tag-parent
Return the current tags parent in the current buffer.
@var{A} tag's parent would be a containing structure, such as a type
containing a field.  Return @code{nil} if there is no parent.

@obsolete{semantic-current-nonterminal-parent,semantic-current-tag-parent}
@end defun

@node Tag Sorting
@section Tag Sorting

Sometimes it is important to reorganize a tag stream into a form that
is better for display to a user.  It is important to not use functions
with side effects that could effect the tag cache.

There are some existing utility functions which will reorganize the
tag list for you.

@defun semantic-bucketize tags &optional parent filter
Sort @var{TAGS} into a group of buckets based on tag class.
Unknown classes are placed in a Misc bucket.
Type bucket names are defined by either `semantic-symbol->name-assoc-list'.
If @var{PARENT} is specified, then @var{TAGS} belong to this @var{PARENT} in some way.
This will use `semantic-symbol->name-assoc-list-for-type-parts' to
generate bucket names.
Optional argument @var{FILTER} is a filter function to be applied to each bucket.
The filter function will take one argument, which is a list of tags, and
may re-organize the list with side-effects.
@end defun

@defvar semantic-bucketize-tag-class
Function used to get a symbol describing the class of a token.
This function must take one argument of a semantic token.
It should return a symbol found in `semantic-symbol->name-assoc-list'
which @dfn{semantic-bucketize} uses to bin up tokens.
To create new bins for an application augment
`semantic-symbol->name-assoc-list', and
`semantic-symbol->name-assoc-list-for-type-parts' in addition
to setting this variable (locally in your function).
@end defvar

@defun semantic-adopt-external-members tags
Rebuild @var{TAGS} so that externally defined members are regrouped.
Some languages such as @var{C}++ and @var{CLOS} permit the declaration of member
functions outside the definition of the class.  It is easier to study
the structure of a program when such methods are grouped together
more logically.

This function uses @dfn{semantic-nonterminal-external-member-p} to
determine when a potential child is an externally defined member.

Note: Applications which use this function must account for tag
types which do not have a position, but have children which *do*
have positions.

Applications should use @code{semantic-mark-external-member-function}
to modify all tags which are found as externally defined to some
type.  For example, changing the tag type for generating extra
buckets with the bucket function.
@end defun

@defvar semantic-orphaned-member-metaparent-type
In @dfn{semantic-adopt-external-members}, the type of @code{'type} for metaparents.
@var{A} metaparent is a made-up type semantic tag used to hold the child list
of orphaned members of a named type.
@end defvar

@defvar semantic-mark-external-member-function
Function called when an externally defined orphan is found.
Be default, the tag is always marked with the @code{adopted} property.
This function should be locally bound by a program that needs
to add additional behaviors into the tag list.
This function is called with one argument which is a shallow copy
of the tag to be modified.  This function should return the
tag (or a copy of it) which is then integrated into the
revised tag list.
@end defvar

@node Tag Completion
@section tag completion

These functions provide ways reading the names of items in a buffer with
completion.


@defun semantic-read-symbol prompt &optional default stream filter
Read a symbol name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@var{FILTER} is provides a filter on the types of things to complete.
@var{FILTER} must be a function to call on each element.  (See !!!
@end defun

@defun semantic-read-variable prompt &optional default stream
Read a variable name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@end defun

@defun semantic-read-function prompt &optional default stream
Read a function name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@end defun

@defun semantic-read-type prompt &optional default stream
Read a type name from the user for the current buffer.
@var{PROMPT} is the prompt to use.
Optional arguments:
@var{DEFAULT} is the default choice.  If no default is given, one is read
from under point.
@var{STREAM} is the list of tags to complete from.
@end defun

@node Override Methods
@section Override Methods

These functions are called `override methods' because they provide
generic behaviors, which a given language can override.  For example,
finding a dependency file in Emacs lisp can be done with the
`locate-library' command (which overrides the default behavior.)  In C,
a dependency can be found by searching a generic search path which can
be passed in via a variable.

@menu
* Format Tag::                  Converting Tokens into text strings
* Tag Details::                 Arbitrary token detail fetching
* Local Context::               Deriving information about a language specific local context.
* Making New Methods::          How to add your own methods for a tool
@end menu

@node Format Tag
@subsection Format Tag

Any given token consists of Meta information which is best viewed in
some textual form.  This could be as simple as the token's name, or as
a prototype to be added to header file in C.  Not only are there
several default converters from a Tag into text, but there is also
some convenient variables that can be used with them.  Use these
variables to allow options on output forms when displaying tags in
your programs.

@defvar semantic-format tag-functions
List of functions which convert a token to text.
Each function must take the parameters @var{TOKEN} &optional @var{PARENT} @var{COLOR}.
@var{TOKEN} is the token to convert.
@var{PARENT} is a parent token or name which refers to the structure
or class which contains @var{TOKEN}.  @var{PARENT} is @var{NOT} a class which a @var{TOKEN}
would claim as a parent.
@var{COLOR} indicates that the generated text should be colored using
@code{font-lock}.
@end defvar

@defvar semantic-format tag-custom-list
@var{A} List used by customizable variables to choose a token to text function.
Use this variable in the @code{:type} field of a customizable variable.
@end defvar

Every token to text conversion function must take the same parameters,
which are @var{TOKEN}, the token to be converted, @var{PARENT}, the
containing parent (like a structure which contains a variable), and
@var{COLOR}, which is a flag specifying that color should be applied
to the returned string.

When creating, or using these strings, particularly with color, use
@dfn{concat} to build up larger strings instead of @dfn{format}.  This
will preserve text properties.

@defun semantic-name-nonterminal token &optional parent color
Return the name string describing @var{TOKEN}.
The name is the shortest possible representation.
Optional argument @var{PARENT} is the parent type if @var{TOKEN} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-summarize-nonterminal token &optional parent color
Summarize @var{TOKEN} in a reasonable way.
Optional argument @var{PARENT} is the parent type if @var{TOKEN} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-prototype-nonterminal token &optional parent color
Return a prototype for @var{TOKEN}.
This function should be overloaded, though it need not be used.
This is because it can be used to create code by language independent
tools.
Optional argument @var{PARENT} is the parent type if @var{TOKEN} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-prototype-file buffer
Return a file in which prototypes belonging to @var{BUFFER} should be placed.
Default behavior (if not overridden) looks for a token specifying the
prototype file, or the existence of an @var{EDE} variable indicating which
file prototypes belong in.
@end defun

@defun semantic-abbreviate-nonterminal token &optional parent color
Return an abbreviated string describing @var{TOKEN}.
The abbreviation is to be short, with possible symbols indicating
the type of token, or other information.
Optional argument @var{PARENT} is the parent type if @var{TOKEN} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-concise-prototype-nonterminal token &optional parent color
Return a concise prototype for @var{TOKEN}.
Optional argument @var{PARENT} is the parent type if @var{TOKEN} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@defun semantic-uml-abbreviate-nonterminal token &optional parent color
Return a @var{UML} style abbreviation for @var{TOKEN}.
Optional argument @var{PARENT} is the parent type if @var{TOKEN} is a detail.
Optional argument @var{COLOR} means highlight the prototype with font-lock colors.
@end defun

@node Tag Details
@subsection Tag Details

These functions help derive information about tokens that may not
be obvious for non-traditional languages with their own token types.

@defun semantic-nonterminal-children token &optional positionalonly
Return the list of top level children belonging to @var{TOKEN}.
Children are any sub-tokens which may contain overlays.
The default behavior (if not overridden with @code{nonterminal-children}
is to return type parts for a type, and arguments for a function.

If optional argument @var{POSITIONALONLY} is non-@code{nil}, then only return valid
children if they contain positions.  Some languages may choose to create
lists of children without position/overlay information.

If this function is overridden, use @dfn{semantic-nonterminal-children-default}
to also include the default behavior, and merely extend your own.

Note for language authors:
  If a mode defines a language that has tokens in it with overlays that
should not be considered children, you should still return them with
this function.  If you do not, then token re-parsing, and database
saving will fail.
@end defun

@defun semantic-nonterminal-external-member-parent token
Return a parent for @var{TOKEN} when @var{TOKEN} is an external member.
@var{TOKEN} is an external member if it is defined at a toplevel and
has some sort of label defining a parent.  The parent return will
be a string.

The default behavior, if not overridden with
@code{nonterminal-external-member-parent} is get the @code{'parent} extra
specifier of @var{TOKEN}.

If this function is overridden, use
@dfn{semantic-nonterminal-external-member-parent-default} to also
include the default behavior, and merely extend your own.
@end defun

@defun semantic-nonterminal-external-member-p parent token
Return non-@code{nil} if @var{PARENT} is the parent of @var{TOKEN}.
@var{TOKEN} is an external member of @var{PARENT} when it is somehow tagged
as having @var{PARENT} as it's parent.

The default behavior, if not overridden with
@code{nonterminal-external-member-p} is to match @code{'parent} extra specifier in
the name of @var{TOKEN}.

If this function is overridden, use
@code{semantic-nonterminal-external-member-children-p-default} to also
include the default behavior, and merely extend your own.
@end defun

@defun semantic-nonterminal-external-member-children token &optional usedb
Return the list of children which are not *in* @var{TOKEN}.
If optional argument @var{USEDB} is non-@code{nil}, then also search files in
the Semantic Database.  If @var{USEDB} is a list of databases, search those
databases.

Children in this case are functions or types which are members of
@var{TOKEN}, such as the parts of a type, but which are not defined inside
the class.  @var{C}++ and @var{CLOS} both permit methods of a class to be defined
outside the bounds of the class' definition.

The default behavior, if not overridden with
@code{nonterminal-external-member-children} is to search using
@dfn{semantic-nonterminal-external-member-p} in all top level definitions
with a parent of @var{TOKEN}.

If this function is overridden, use
@dfn{semantic-nonterminal-external-member-children-default} to also
include the default behavior, and merely extend your own.
@end defun

@defun semantic-nonterminal-protection token &optional parent
Return protection information about @var{TOKEN} with optional @var{PARENT}.
This function returns on of the following symbols:
   @code{nil}      - No special protection.  Language dependent.
   @code{'public}  - Anyone can access this @var{TOKEN}.
   @code{'private} - Only methods in the local scope can access @var{TOKEN}.
   @code{'friend}  - Like private, except some outer scopes are allowed
              access to token.
Some languages may choose to provide additional return symbols specific
to themselves.  Use of this function should allow for this.

The default behavior (if not overridden with @code{nonterminal-protection}
is to return a symbol based on type modifiers.
@end defun

@defun semantic-nonterminal-abstract token &optional parent
Return non @code{nil} if @var{TOKEN} is abstract.
Optional @var{PARENT} is the parent token of @var{TOKEN}.
In @var{UML}, abstract methods and classes have special meaning and behavior
in how methods are overridden.  In @var{UML}, abstract methods are italicized.

The default behavior (if not overridden with @code{nonterminal-abstract}
is to return true if @code{abstract} is in the type modifiers.
@end defun

@defun semantic-nonterminal-leaf token &optional parent
Return non @code{nil} if @var{TOKEN} is leaf.
Optional @var{PARENT} is the parent token of @var{TOKEN}.
In @var{UML}, leaf methods and classes have special meaning and behavior.

The default behavior (if not overridden with @code{nonterminal-leaf}
is to return true if @code{leaf} is in the type modifiers.
@end defun

@defun semantic-nonterminal-static token &optional parent
Return non @code{nil} if @var{TOKEN} is static.
Optional @var{PARENT} is the parent token of @var{TOKEN}.
In @var{UML}, static methods and attributes mean that they are allocated
in the parent class, and are not instance specific.
@var{UML} notation specifies that @var{STATIC} entries are underlined.

The default behavior (if not overridden with @code{nonterminal-static}
is to return true if @code{static} is in the type modifiers.
@end defun

@defun semantic-find-dependency token
Find the filename represented from @var{TOKEN}.
@var{TOKEN} may be a stripped element, in which case @var{PARENT} specifies a
parent token that has positional information.
Depends on @code{semantic-dependency-include-path} for searching.  Always searches
`.' first, then searches additional paths.


@defvar semantic-dependency-include-path
Defines the include path used when searching for files.
This should be a list of directories to search which is specific to
the file being included.
This variable can also be set to a single function.  If it is a
function, it will be called with one arguments, the file to find as a
string, and  it should return the full path to that file, or nil.
@end defvar


@end defun


@defun semantic-find-nonterminal token &optional parent
Find the location of @var{TOKEN}.
@var{TOKEN} may be a stripped element, in which case @var{PARENT} specifies a
parent token that has position information.
Different behaviors are provided depending on the type of token.
For example, dependencies (includes) will seek out the file that is
depended on, and functions will move to the specified definition.
@end defun

@defun semantic-find-documentation token
Find documentation from @var{TOKEN} and return it as a clean string.
@var{TOKEN} might have @var{DOCUMENTATION} set in it already.  If not, there may be
some documentation in a comment preceding TOKEN's definition which we
can look for.  When appropriate, this can be overridden by a language specific
enhancement.
@end defun

@node Local Context
@subsection Local Context

@defun semantic-up-context &optional point
Move point up one context from @var{POINT}.
Return non-@code{nil} if there are no more context levels.
Overloaded functions using @code{up-context} take no parameters.
@end defun

@defun semantic-beginning-of-context &optional point
Move @var{POINT} to the beginning of the current context.
Return non-@code{nil} if there is no upper context.
The default behavior uses @dfn{semantic-up-context}.  It can
be overridden with @code{beginning-of-context}.
@end defun

@defun semantic-end-of-context &optional point
Move @var{POINT} to the end of the current context.
Return non-@code{nil} if there is no upper context.
Be default, this uses @dfn{semantic-up-context}, and assumes parenthetical
block delimiters.  This can be overridden with @code{end-of-context}.
@end defun

@defun semantic-get-local-variables &optional point
Get the local variables based on POINT's context.
Local variables are returned in Semantic token format.
Be default, this calculates the current bounds using context blocks
navigation, then uses the parser with @code{bovine-inner-scope} to
parse tokens at the beginning of the context.
This can be overridden with @code{get-local-variables}.
@end defun

@defun semantic-get-local-arguments &optional point
Get arguments (variables) from the current context at @var{POINT}.
Parameters are available if the point is in a function or method.
This function returns a list of tokens.  If the local token returns
just a list of strings, then this function will convert them to tokens.
Part of this behavior can be overridden with @code{get-local-arguments}.
@end defun

@defun semantic-get-all-local-variables &optional point
Get all local variables for this context, and parent contexts.
Local variables are returned in Semantic token format.
Be default, this gets local variables, and local arguments.
This can be overridden with @code{get-all-local-variables}.
Optional argument @var{POINT} is the location to start getting the variables from.
@end defun

These next set of functions handle local context parsing.   This means
looking at the code (locally) and navigating, and fetching information
such as a the type of the parameter the cursor may be typing in.

@defun semantic-end-of-command
Move to the end of the current command.
Be default, uses @code{semantic-command-separation-character}.
Override with @code{end-of-command}.
@end defun

@defun semantic-beginning-of-command
Move to the beginning of the current command.
Be default, users @code{semantic-command-separation-character}.
Override with @code{beginning-of-command}.
@end defun

@defun semantic-ctxt-current-symbol &optional point
Return the current symbol the cursor is on at @var{POINT} in a list.
This will include a list of type/field names when applicable.
This can be overridden using @code{ctxt-current-symbol}.
@end defun

@defun semantic-ctxt-current-assignment &optional point
Return the current assignment near the cursor at @var{POINT}.
Return a list as per @dfn{semantic-ctxt-current-symbol}.
Return @code{nil} if there is nothing relevant.
Override with @code{ctxt-current-assignment}.
@end defun

@defun semantic-ctxt-current-function &optional point
Return the current function the cursor is in at @var{POINT}.
The function returned is the one accepting the arguments that
the cursor is currently in.
This can be overridden with @code{ctxt-current-function}.
@end defun

@defun semantic-ctxt-current-argument &optional point
Return the current symbol the cursor is on at @var{POINT}.
Override with @code{ctxt-current-argument}.
@end defun

@defun semantic-ctxt-scoped-types &optional point
Return a list of type names currently in scope at @var{POINT}.
Override with @code{ctxt-scoped-types}.
@end defun

For details on using these functions to get more detailed information
about the current context: @xref{Context Analysis}.

@node Making New Methods
@subsection Making New Methods

@node Parser Hooks
@section Parser Hooks

If you write a program that uses a tag table in a persistent
display or database, it is necessary to know when tag tables change so
that your displays can be updated.  This is especially important as
tags can be replaced, changed, or deleted, and the associated
overlays will then throw errors when you try to use them.  Complete
integration with tag changes can be achieved via several hooks.

One interesting way to interact with the parser is to let it know that
changes you are going to make will not require re-parsing.

@defvar semantic-edits-are-safe
When non-@code{nil}, modifications do not require a reparse.
This prevents tokens from being marked dirty, and it
prevents top level edits from causing a cache check.
Use this when writing programs that could cause a full
reparse, but will not change the tag structure, such
as adding or updating top-level comments.
@end defvar

Next, it is sometimes useful to know what the current parsing state
is.  These function can let you know what level of re-parsing may be
needed.  Careful choices on when to reparse can make your program much
faster.

@defun semantic-bovine-toplevel-full-reparse-needed-p &optional checkcache
Return non-@code{nil} if the current buffer needs a full reparse.
Optional argument @var{CHECKCACHE} indicates if the cache check should be made.
@end defun

@defun semantic-bovine-toplevel-partial-reparse-needed-p &optional checkcache
Return non-@code{nil} if the current buffer needs a partial reparse.
This only returns non-@code{nil} if @dfn{semantic-bovine-toplevel-full-reparse-needed-p}
returns nil.
Optional argument @var{CHECKCACHE} indicates if the cache check should be made
when checking @dfn{semantic-bovine-toplevel-full-reparse-needed-p}.
@end defun

If you just want to know when a buffer changes, use this hook.

@defvar semantic-after-toplevel-cache-change-hook
Hooks run after the buffer token list has changed.
This list will change when a buffer is re-parsed, or when the token
list in a buffer is cleared.  It is *NOT* called if the current token
list partially re-parsed.

Hook functions must take one argument, which is the new list of
tokens associated with this buffer.

For language specific hooks, make sure you define this as a local hook.

@obsolete{semantic-after-toplevel-bovinate-hook}
@end defvar

If you want tighter interaction with how the user is editing
different tags, you can use this hook instead.

@defvar semantic-after-partial-cache-change-hook
Hooks run after the buffer token list has been updated.
This list will change when the current token list has been partially
re-parsed.

Hook functions must take one argument, which is the list of tokens
updated among the ones associated with this buffer.

For language specific hooks, make sure you define this as a local hook.
@end defvar

@defvar semantic-before-toplevel-cache-flush-hook
Hooks run before the toplevel nonterminal cache is flushed.
For language specific hooks, make sure you define this as a local hook.
This hook is called before a corresponding
@code{semantic-after-toplevel-cache-change-hook} which is also called
during a flush when the cache is given a new value of nil.
@end defvar

@node Example Programs
@section Programming Examples

Here are some simple examples that use different aspects of the
semantic library APIs.  For fully functional example programs with
lots of comments, see the file @file{semantic-examples.el}.

@heading Interactively querying for a token name

If you need a command that asks the user for a token name, you can
get full range completion using the query functions
@ref{Tag Completion}.

@example
(interactive (list (semantic-read-symbol "Symbol: ")))
@end example

@heading Finding a symbol in a buffer

If you have the name of a function or variable, and need to find its
location in a buffer, you need a search function.  There is a wide
range of searches you can perform @ref{Tag Tables}.

@example
(semantic-find-nonterminal-by-name
 "some-name"
 (current-buffer)
 t    ;; look inside structures and classes for these symbols
 nil) ;; do not look inside header files.
@end example

@heading Finding a symbol in a project

If you have the name of a function or variable, and need to find its
location somewhere in a project, you need to use the Semantic Database
@ref{semanticdb}.  There are many search functions similar to the
ones found in @ref{Tag Tables}.

The Semantic Database is interesting in that the return structure is
not

@heading Locating a token in a buffer

If you have a nonterminal token, or a list of them, you may want to
find their position in a buffer.

@example
(semanticdb-find-nonterminal-by-name
 "symbol"
 nil   ;; Defaults to the current project's database list.
 t     ;; Search inside types
 nil   ;; Do not search include files
 nil   ;; Only search files in the same mode (all C files)
 t     ;; When a token is found, make sure it is loaded in a buffer.
 )
@end example

Of interesting note above, semanticdb can find symbols in files that
are not loaded into an Emacs buffer.  These tokens do not have an
associated overlay, and the function @dfn{semantic-token-buffer} will
fail.

The last parameter's tells the search function to
@dfn{find-file-noselect} any file in which a matching token was
found.  This will allow you to merge all the tokens into a completion
list, or other flat list needed by most functions that use
association lists.

If you do not ask semanticdb to load those files, you will need to
explicitly request the database object (found in the @code{car} of
each sublist) get the file loaded.  It is useful to not auto find all
files if you don't need to jump to that token.

@heading Converting a token into a human readable string.

A tag is a rather unpleasant Lisp structure when trying
to decipher what is going on.  As such, there is a wide range of
functions available that can convert a token into a human readable,
and colorful string @ref{Format Tag}.

If you program interfaces with lots of users, you will probably want
to have your program define a configurable variable that will let
users change the visible portion of your program.

@example
(defcustom my-summary-function 'semantic-uml-prototype-nonterminal
  "*Function to use when showing info about my tag."
  :group 'my-program
  :type semantic-format-tag-custom-list)
@end example

Note the special type provided by Semantic.

Next, you can call this function to create a string.

@example
(funcall my-summary-function tag
                             tag-parent
                             t ; use color
                             )
@end example

In this case, @var{tag-parent} is an optional argument.  In many
cases, parent is not used by the outputting function.  The parent must
be a tag whose @code{semantic-tag-componenets} contains @var{tag}, or
nil for top-level definitions.  In particular, C++ needs the parent to
correctly calculate the protection of each method.


@node Current Context
@section Deriving the Current Context

This chapter deals with how to derive the current context, and also
how a language maintainer can get the current context API to work
with their language.

By default, the behavior will function in C like languages.  This
means languages with parenthetical blocks, and type dereferencing
which uses a similar form.

@menu
* Blocks::                      
* Local Variables::             Getting lists of local variables.
* Derived Context::             What goes at a given location?
* Context Analysis::            Analysis information about the local context.
@end menu

@node Blocks
@subsection Blocks and Navigation

Source code is typically built up of control structures, and blocks of
context, or lexical scope.  Semantic terms these lexical scopes as a
``context''.  The following functions can be used to navigate contexts.
Some of them are override functions.  Language authors can override
a subset of them to make them work for their language.

@defun semantic-up-context &optional point
Move point up one context from @var{POINT}.
Return non-@code{nil} if there are no more context levels.
Overloaded functions using @code{up-context} take no parameters.
@end defun

@defun semantic-beginning-of-context &optional point
Move @var{POINT} to the beginning of the current context.
Return non-@code{nil} if there is no upper context.
The default behavior uses @code{semantic-up-context}.  It can
be overridden with @code{beginning-of-context}.
@end defun

@defun semantic-end-of-context &optional point
Move @var{POINT} to the end of the current context.
Return non-@code{nil} if there is no upper context.
Be default, this uses @code{semantic-up-context}, and assumes parenthetical
block delimiters.  This can be overridden with @code{end-of-context}.
@end defun

These next set of functions can be used to navigate across commands.

@defun semantic-end-of-command
Move to the end of the current command.
Be default, uses @code{semantic-command-separation-character}.
Override with @code{end-of-command}.
@end defun

@defun semantic-beginning-of-command
Move to the beginning of the current command.
Be default, users @code{semantic-command-separation-character}.
Override with @code{beginning-of-command}.
@end defun

@node Local Variables
@subsection Deriving local variables

Within a given context, or block of code, local variables are often
defined.  These functions can be used to retrieve lists of locally
scoped variables.

@defun semantic-get-local-variables &optional point
Get the local variables based on POINT's context.
Local variables are returned in Semantic token format.
By default, this calculates the current bounds using context blocks
navigation, then uses the parser with @code{bovine-inner-scope} to
parse tokens at the beginning of the context.
This can be overridden with @code{get-local-variables}.
@end defun

@defun semantic-get-local-arguments &optional point
Get arguments (variables) from the current context at @var{POINT}.
Parameters are available if the point is in a function or method.
This function returns a list of tokens.  If the local token returns
just a list of strings, then this function will convert them to tokens.
Part of this behavior can be overridden with @code{get-local-arguments}.
@end defun

@defun semantic-get-all-local-variables &optional point
Get all local variables for this context, and parent contexts.
Local variables are returned in Semantic token format.
Be default, this gets local variables, and local arguments.
This can be overridden with @code{get-all-local-variables}.
Optional argument @var{POINT} is the location to start getting the variables from.
@end defun

@node Derived Context
@subsection Deriving the Current Context

While a context has already been used to describe blocks of code,
other context include more local details, such as the symbol the
cursor is on, or the fact we are assigning into some other variable.

These context deriving functions can be overridden to provide language
specific behavior.  By default, it assumes a C like language.

@defun semantic-ctxt-current-symbol &optional point
Return the current symbol the cursor is on at @var{POINT} in a list.
This will include a list of type/field names when applicable.
This can be overridden using @code{ctxt-current-symbol}.
@end defun

@defun semantic-ctxt-current-assignment &optional point
Return the current assignment near the cursor at @var{POINT}.
Return a list as per @code{semantic-ctxt-current-symbol}.
Return @code{nil} if there is nothing relevant.
Override with @code{ctxt-current-assignment}.
@end defun

@defun semantic-ctxt-current-function &optional point
Return the current symbol the cursor is on at @var{POINT}.
The function returned is the one accepting the arguments that
the cursor is currently in.
This can be overridden with `ctxt.current-function'.
@end defun

@defun semantic-ctxt-current-argument &optional point
Return the current symbol the cursor is on at @var{POINT}.
Override with @code{ctxt-current-argument}.
@end defun

@node Context Analysis
@subsection Analysis of the current context

The context parsing API is used in a context analysis library.  This
library provides high level routines for scanning through token
databases to create lists of token associates.  At it's core is a set
of EIEIO classes defining a context.  The context contains information
about what was parsed at a given position, such as the strings there,
and they type of assignment.  The analysis library then searches the
databases to determine the types and names available.

Two high level functions which can be run interactively are:

*NOTE TO SELF: Add more here*

@deffn Command semantic-analyze-current-context position
Analyze the current context at @var{POSITION}.
If called interactively, display interesting information about @var{POSITION}
in a separate buffer.
Returns an object based on symbol @code{semantic-analyze-context}.
@end deffn


@deffn Command semantic-analyze-possible-completions point
Return a list of semantic tokens which are possible completions.
Analysis is done at @var{POINT}.
@end deffn
